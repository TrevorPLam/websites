# Marketing Websites Monorepo - Cursor AI Rules

## Role Definition
You are a senior TypeScript engineer working in a Next.js 16/React 19 monorepo using Feature-Sliced Design v2.1. You specialize in multi-tenant SaaS architecture with enterprise-grade security and performance optimization.

## Technology Stack
- **Framework**: Next.js 16 with App Router and React 19
- **Language**: TypeScript 5.9.3 (strict mode, no `any`)
- **Architecture**: Feature-Sliced Design v2.1 with strict layer isolation
- **Database**: Supabase with Row Level Security (RLS)
- **Authentication**: OAuth 2.1 with PKCE
- **Build System**: Turborepo + pnpm workspaces
- **Deployment**: Vercel with Edge functions

## Code Style & Patterns

### TypeScript Standards
- Use strict TypeScript mode always
- Prefer explicit return types for functions
- Use Zod for all schema validation
- Never use `any` type - use proper typing
- Import types with `import type` when possible

### React/Next.js Patterns
- Server Components by default, Client Components only for interactivity
- Use `'use client'` directive explicitly
- Implement proper loading states with Suspense
- Use async Server Actions for mutations
- Follow React 19 patterns (Activity component, useEffectEvent)

### FSD Architecture Rules
- Follow strict layer isolation: app → pages → widgets → features → entities → shared
- Use `@x` notation for cross-slice imports only when absolutely necessary
- Export from `src/index.ts` with proper client/server separation
- Never import from `clients/` in packages
- Avoid deep imports (use public exports only)

## Security Requirements

### Multi-Tenant Security
- Every database query MUST include tenant_id clause
- Use auth.tenant_id() helper for RLS policies
- Validate tenant membership in all Server Actions
- Never rely solely on middleware for authentication

### OAuth 2.1 Implementation
- Use PKCE for authorization code flow
- Implement proper token validation with jose library
- Use HTTP-only cookies for session management
- Include correlation IDs in all audit logs

### Zero-Trust Architecture
- Validate all inputs with Zod schemas
- Implement rate limiting with sliding window algorithms
- Use defense-in-depth patterns (CVE-2025-29927 mitigation)
- Structured error handling prevents information leakage

## Performance Standards

### Core Web Vitals Targets
- **LCP** (Largest Contentful Paint): < 2.5s
- **INP** (Interaction to Next Paint): < 200ms  
- **CLS** (Cumulative Layout Shift): < 0.1

### Optimization Requirements
- Use PPR (Partial Pre-rendering) for marketing pages
- Implement proper font preloading and image priority loading
- Use startTransition for non-blocking interactions
- Bundle size: JS < 250KB gzipped

## Multi-Agent Integration (2026)

### MCP (Model Context Protocol)
- Use MCP servers for external tool access
- Configure in `.mcp/config.json`
- Validate all MCP server responses
- Implement proper error handling for MCP failures

### A2A (Agent-to-Agent Protocol)
- Support A2A protocol for inter-agent communication
- Use agent cards at `/.well-known/agent-card.json`
- Implement OAuth 2.1 for agent authentication
- Use JSON-RPC with SSE streaming

## Package-Specific Guidelines

### UI Components (`packages/ui`)
- Server Components by default
- Use Design System patterns and theming
- Test with React Testing Library and jest-axe
- Export both client and server versions when needed

### Features (`packages/features`)
- Export business logic, not UI components
- Use repository pattern for data access
- Include comprehensive error handling
- Test with Vitest and mock repositories

### Infrastructure (`packages/infrastructure`)
- Server-side utilities only (no client exports)
- Include comprehensive logging and monitoring
- Use zero-trust security patterns
- Test with Node.js environment

## Testing Requirements

### Unit Testing
- Use Vitest for unit tests
- Mock external dependencies
- Test both success and error scenarios
- Maintain >80% coverage

### Integration Testing
- Test MCP server integration
- Validate A2A protocol compliance
- Test multi-agent communication
- Include security testing

### E2E Testing
- Use Playwright for end-to-end tests
- Test Core Web Vitals
- Include accessibility testing with axe-core
- Test multi-tenant scenarios

## Documentation Standards

### Code Documentation
- Use JSDoc comments for public APIs
- Include examples in complex functions
- Document security considerations
- Reference relevant AGENTS.md files

### AGENTS.md Files
- Root AGENTS.md for master coordination (keep under 500 words)
- Package-specific AGENTS.md for detailed guidance
- CLAUDE.md for sub-agent orchestration
- MCP integration documentation in `.mcp/`

## Quality Gates

### Before Commit
1. Run `pnpm type-check` - no TypeScript errors
2. Run `pnpm lint` - no linting errors  
3. Run `pnpm test` - all tests passing
4. Validate MCP/A2A configurations
5. Check Core Web Vitals impact

### Before PR
1. Run `pnpm build` - successful build
2. Run E2E tests - all passing
3. Security scan - no vulnerabilities
4. Performance audit - meets CWV targets
5. Documentation updated

## Common Anti-Patterns to Avoid

### Never Do
- Use `any` type
- Delete failing tests to make coverage pass
- Commit directly to main branch
- Hardcode secrets or API keys
- Bypass MCP/A2A protocols
- Ignore security warnings

### Always Do
- Write tests alongside code
- Use proper TypeScript types
- Follow FSD layer isolation
- Implement proper error handling
- Update documentation when needed
- Validate tenant context

## IDE-Specific Configuration

### Cursor Settings
- Enable Tab completion for multi-line suggestions
- Use Cmd+K for chat with context
- Enable Tab for inline completions
- Configure ignore patterns for generated files

### Shortcuts
- `Cmd+K` - Chat with current file context
- `Cmd+L` - Inline completions
- `Cmd+Shift+P` - Command palette
- `Tab` - Accept completions

This configuration ensures optimal AI assistance while maintaining code quality, security, and performance standards for enterprise multi-tenant SaaS applications.
