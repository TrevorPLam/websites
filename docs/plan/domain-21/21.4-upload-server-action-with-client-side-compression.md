### 21.4 Upload Server Action (with Client-Side Compression)

**Client-side compression via `browser-image-compression` before upload — reduces Supabase egress costs by 6–8× for typical user photos.** [youtube](https://www.youtube.com/watch?v=FcisLdkZ_Aw)

**File:** `apps/portal/src/features/assets/model/upload-asset.ts`

```typescript
'use server';

import { z } from 'zod';
import { createServerAction } from '@repo/auth/server-action-wrapper';
import { createClient } from '@supabase/supabase-js';

const supabaseAdmin = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

const UploadAssetSchema = z.object({
  fileName: z.string().min(1).max(255),
  fileType: z.enum(['image/jpeg', 'image/png', 'image/webp', 'image/svg+xml', 'image/gif']),
  fileSize: z.number().max(5 * 1024 * 1024), // 5MB max
  assetType: z.enum(['logo', 'favicon', 'service-image', 'hero-image', 'gallery']),
});

export const getUploadUrl = createServerAction(UploadAssetSchema, async (input, ctx) => {
  const { tenantId } = ctx;
  const { fileName, fileType, assetType } = input;

  // Sanitize filename (prevent path traversal)
  const ext = fileName.split('.').pop()?.toLowerCase() ?? 'jpg';
  const safeFileName = `${assetType}-${Date.now()}.${ext}`;
  const storagePath = `${tenantId}/${safeFileName}`;

  // Generate a signed upload URL (5 min expiry)
  // Client uploads directly to Supabase — file never passes through our server
  const { data, error } = await supabaseAdmin.storage
    .from('tenant-assets')
    .createSignedUploadUrl(storagePath, { upsert: true });

  if (error || !data) {
    throw new Error(`Failed to generate upload URL: ${error?.message}`);
  }

  return {
    uploadUrl: data.signedUrl,
    token: data.token,
    path: storagePath,
    publicUrl: `${process.env.NEXT_PUBLIC_SUPABASE_URL}/storage/v1/object/public/tenant-assets/${storagePath}`,
  };
});

// Called after successful upload to store URL in tenant config
const ConfirmAssetSchema = z.object({
  assetType: z.enum(['logo', 'favicon', 'service-image', 'hero-image']),
  publicUrl: z.string().url(),
  storagePath: z.string(),
});

export const confirmAssetUpload = createServerAction(ConfirmAssetSchema, async (input, ctx) => {
  const { tenantId } = ctx;
  const { assetType, publicUrl } = input;

  // Map asset type to config path
  const configKeyMap: Record<string, string> = {
    logo: 'assets.logo',
    favicon: 'assets.favicon',
  };

  const configKey = configKeyMap[input.assetType];
  if (configKey) {
    // Deep-merge asset URL into config
    await import('@repo/db').then(({ db }) =>
      db
        .from('tenants')
        .update({
          [`config`]: db.raw(
            `jsonb_set(config, '{${configKey.replace('.', ',')}}', '"${publicUrl}"'::jsonb)`
          ),
        })
        .eq('id', tenantId)
    );
  }

  return { success: true, url: publicUrl };
});
```

**Client-side upload component with compression:**

**File:** `apps/portal/src/features/assets/ui/AssetUploader.tsx`

```typescript
'use client';

import { useState, useCallback } from 'react';
import imageCompression from 'browser-image-compression';
import { getUploadUrl, confirmAssetUpload } from '../model/upload-asset';

interface AssetUploaderProps {
  assetType: 'logo' | 'favicon' | 'service-image' | 'hero-image';
  currentUrl?: string;
  label: string;
  aspectHint?: string;             // e.g. "square (1:1)" or "wide (16:9)"
  onUploadComplete?: (url: string) => void;
}

const COMPRESSION_OPTIONS = {
  logo: { maxSizeMB: 0.3, maxWidthOrHeight: 800, useWebWorker: true },
  favicon: { maxSizeMB: 0.05, maxWidthOrHeight: 64, useWebWorker: true },
  'service-image': { maxSizeMB: 0.5, maxWidthOrHeight: 1200, useWebWorker: true },
  'hero-image': { maxSizeMB: 0.8, maxWidthOrHeight: 1920, useWebWorker: true },
};

export function AssetUploader({
  assetType,
  currentUrl,
  label,
  aspectHint,
  onUploadComplete,
}: AssetUploaderProps) {
  const [uploading, setUploading] = useState(false);
  const [progress, setProgress] = useState(0);
  const [preview, setPreview] = useState<string | null>(currentUrl ?? null);
  const [error, setError] = useState<string | null>(null);

  const handleFileChange = useCallback(
    async (e: React.ChangeEvent<HTMLInputElement>) => {
      const file = e.target.files?.[0];
      if (!file) return;

      setError(null);
      setUploading(true);
      setProgress(0);

      try {
        // 1. Client-side compression (before upload)
        setProgress(10);
        const options = COMPRESSION_OPTIONS[assetType];
        const compressed = await imageCompression(file, {
          ...options,
          onProgress: (p) => setProgress(10 + Math.round(p * 0.4)), // 10-50%
        });

        // 2. Get signed upload URL from server
        setProgress(50);
        const urlResult = await getUploadUrl({
          fileName: file.name,
          fileType: file.type as any,
          fileSize: compressed.size,
          assetType,
        });

        if (!urlResult.success || !urlResult.data) {
          throw new Error('Failed to get upload URL');
        }

        const { uploadUrl, publicUrl, storagePath } = urlResult.data;

        // 3. Direct upload to Supabase (client → Supabase, bypasses our server)
        setProgress(60);
        const uploadResponse = await fetch(uploadUrl, {
          method: 'PUT',
          body: compressed,
          headers: { 'Content-Type': compressed.type },
        });

        if (!uploadResponse.ok) {
          throw new Error(`Upload failed: ${uploadResponse.status}`);
        }

        setProgress(90);

        // 4. Confirm upload in our DB
        await confirmAssetUpload({ assetType, publicUrl, storagePath });

        setProgress(100);
        setPreview(URL.createObjectURL(compressed));
        onUploadComplete?.(publicUrl);
      } catch (err: any) {
        setError(err.message ?? 'Upload failed. Please try again.');
        console.error('[AssetUploader] Error:', err);
      } finally {
        setUploading(false);
      }
    },
    [assetType, onUploadComplete]
  );

  const inputId = `asset-upload-${assetType}`;

  return (
    <div>
      <label className="block text-sm font-medium text-gray-700 mb-2" htmlFor={inputId}>
        {label}
        {aspectHint && <span className="ml-1 text-gray-400 font-normal text-xs">({aspectHint})</span>}
      </label>

      <div
        className={`
          relative flex flex-col items-center justify-center w-full rounded-xl border-2 border-dashed
          ${uploading ? 'border-primary/40 bg-primary/5' : 'border-gray-300 hover:border-gray-400'}
          transition-colors cursor-pointer
          ${assetType === 'favicon' ? 'h-24' : 'h-40'}
        `}
      >
        {preview ? (
          <div className="absolute inset-0 flex items-center justify-center p-4">
            {/* eslint-disable-next-line @next/next/no-img-element */}
            <img
              src={preview}
              alt={`${label} preview`}
              className="max-h-full max-w-full object-contain rounded"
            />
          </div>
        ) : (
          <div className="text-center p-4">
            <svg aria-hidden="true" className="mx-auto h-8 w-8 text-gray-400 mb-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
            </svg>
            <p className="text-sm text-gray-500">
              <span className="text-primary font-medium">Click to upload</span> or drag & drop
            </p>
            <p className="text-xs text-gray-400 mt-1">PNG, JPG, WebP, SVG</p>
          </div>
        )}

        <input
          id={inputId}
          type="file"
          accept="image/*"
          onChange={handleFileChange}
          disabled={uploading}
          className="absolute inset-0 w-full h-full opacity-0 cursor-pointer disabled:cursor-not-allowed"
          aria-label={`Upload ${label}`}
          aria-busy={uploading}
        />
      </div>

      {/* Progress bar */}
      {uploading && (
        <div
          role="progressbar"
          aria-valuenow={progress}
          aria-valuemin={0}
          aria-valuemax={100}
          aria-label={`Uploading ${label}: ${progress}%`}
          className="mt-2 h-1.5 bg-gray-200 rounded-full overflow-hidden"
        >
          <div
            className="h-full bg-primary rounded-full transition-all duration-300"
            style={{ width: `${progress}%` }}
          />
        </div>
      )}

      {error && (
        <p role="alert" className="mt-2 text-sm text-red-600">{error}</p>
      )}

      {preview && !uploading && (
        <p className="mt-1 text-xs text-green-600">✓ Uploaded successfully</p>
      )}
    </div>
  );
}
```

---
