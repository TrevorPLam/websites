### 33.4 Right to Erasure — Data Deletion System

**File:** `packages/privacy/src/erasure.ts`

```typescript
import { db } from '@repo/db';
import { createClient } from '@supabase/supabase-js';

// ============================================================================
// GDPR ARTICLE 17 — RIGHT TO ERASURE IMPLEMENTATION
// Two erasure types:
//   1. Hard delete: physically removes records (used for leads/bookings)
//   2. Anonymization: replaces PII with pseudonymous tokens (used where
//      records must be retained for billing/legal audit trail)
//
// EDPB 2025 enforcement: controllers must respond within 30 days.
// Reference: https://gdpr-info.eu/art-17-gdpr/
// ============================================================================

const supabaseAdmin = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

const ANONYMIZED_EMAIL_SUFFIX = '@anonymized.invalid';
const ANONYMIZED_NAME = '[Anonymized]';
const ANONYMIZED_PHONE = '[Anonymized]';

export interface ErasureRequest {
  requestId: string;
  tenantId: string;
  subjectEmail: string; // The person requesting erasure
  requestedAt: string;
  requestedBy: 'subject' | 'tenant_admin' | 'agency_admin';
  reason?: string;
}

export interface ErasureResult {
  requestId: string;
  deletedLeads: number;
  deletedBookings: number;
  anonymizedLeads: number; // Leads retained but anonymized (financial records)
  deletedFiles: number;
  completedAt: string;
}

export async function processErasureRequest(request: ErasureRequest): Promise<ErasureResult> {
  const { tenantId, subjectEmail, requestId } = request;
  const normalizedEmail = subjectEmail.toLowerCase().trim();

  // Log the request first (audit trail — required by GDPR Article 5(2))
  await db.from('erasure_requests').upsert({
    id: requestId,
    tenant_id: tenantId,
    subject_email: normalizedEmail,
    requested_at: request.requestedAt,
    requested_by: request.requestedBy,
    reason: request.reason,
    status: 'processing',
  });

  let deletedLeads = 0;
  let deletedBookings = 0;
  let anonymizedLeads = 0;
  let deletedFiles = 0;

  try {
    // ── 1. Leads — hard delete (no legitimate retention interest) ────────────

    const { data: leadsToDelete, count } = await db
      .from('leads')
      .select('id', { count: 'exact' })
      .eq('tenant_id', tenantId)
      .eq('email', normalizedEmail);

    if (leadsToDelete?.length) {
      await db.from('leads').delete().eq('tenant_id', tenantId).eq('email', normalizedEmail);

      deletedLeads = count ?? leadsToDelete.length;
    }

    // ── 2. Bookings — anonymize (financial/legal audit trail required) ───────
    // Booking records may need to be retained for accounting purposes.
    // PII (name, email, phone) is replaced with pseudonymous tokens.
    // The booking UID (used for calendar sync) is retained.

    const { data: bookingsToAnonymize } = await db
      .from('bookings')
      .select('id')
      .eq('tenant_id', tenantId)
      .eq('attendee_email', normalizedEmail);

    if (bookingsToAnonymize?.length) {
      const anonymizedSuffix = requestId.slice(0, 8); // Stable per request

      await db
        .from('bookings')
        .update({
          attendee_name: ANONYMIZED_NAME,
          attendee_email: `${anonymizedSuffix}${ANONYMIZED_EMAIL_SUFFIX}`,
          attendee_phone: ANONYMIZED_PHONE,
          metadata: db.raw(`metadata - 'responses'`), // Remove form responses (PII)
          updated_at: new Date().toISOString(),
        })
        .eq('tenant_id', tenantId)
        .eq('attendee_email', normalizedEmail);

      anonymizedLeads = bookingsToAnonymize.length;
    }

    // ── 3. Chat session data ─────────────────────────────────────────────────

    await db
      .from('chat_sessions')
      .delete()
      .eq('tenant_id', tenantId)
      .eq('visitor_email', normalizedEmail);

    // ── 4. Storage files (profile images, uploaded documents) ────────────────

    const { data: files } = await supabaseAdmin.storage
      .from('tenant-documents')
      .list(`${tenantId}/leads/${normalizedEmail}`);

    if (files?.length) {
      const filePaths = files.map((f) => `${tenantId}/leads/${normalizedEmail}/${f.name}`);
      await supabaseAdmin.storage.from('tenant-documents').remove(filePaths);
      deletedFiles = files.length;
    }

    // ── 5. Mark erasure request as complete ───────────────────────────────────

    await db
      .from('erasure_requests')
      .update({
        status: 'completed',
        completed_at: new Date().toISOString(),
        result: {
          deletedLeads,
          deletedBookings,
          anonymizedLeads,
          deletedFiles,
        },
      })
      .eq('id', requestId);

    const result: ErasureResult = {
      requestId,
      deletedLeads,
      deletedBookings,
      anonymizedLeads,
      deletedFiles,
      completedAt: new Date().toISOString(),
    };

    console.log(`[GDPR] Erasure complete for ${normalizedEmail} (tenant=${tenantId}):`, result);

    return result;
  } catch (err) {
    // Mark as failed — operator must be notified
    await db
      .from('erasure_requests')
      .update({
        status: 'failed',
        error: String(err),
      })
      .eq('id', requestId);

    throw err;
  }
}

// ── Data export (GDPR Article 20 — Right to Data Portability) ────────────────

export async function exportSubjectData(
  tenantId: string,
  subjectEmail: string
): Promise<Record<string, unknown>> {
  const normalizedEmail = subjectEmail.toLowerCase().trim();

  const [leads, bookings, chatSessions] = await Promise.all([
    db.from('leads').select('*').eq('tenant_id', tenantId).eq('email', normalizedEmail),
    db.from('bookings').select('*').eq('tenant_id', tenantId).eq('attendee_email', normalizedEmail),
    db
      .from('chat_sessions')
      .select('*')
      .eq('tenant_id', tenantId)
      .eq('visitor_email', normalizedEmail),
  ]);

  return {
    exportDate: new Date().toISOString(),
    dataController: tenantId,
    dataSubject: { email: normalizedEmail },
    data: {
      leads: leads.data ?? [],
      bookings: (bookings.data ?? []).map((b) => ({
        ...b,
        // Exclude internal IDs that are meaningless to the subject
        cal_uid: undefined,
        tenant_id: undefined,
      })),
      chatSessions: chatSessions.data ?? [],
    },
  };
}
```

---
