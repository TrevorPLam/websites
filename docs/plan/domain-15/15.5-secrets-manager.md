### 15.5 Secrets Manager

**File:** `packages/security/src/secrets-manager.ts`

```typescript
import { Redis } from '@upstash/redis';
import { createClient } from '@supabase/supabase-js';
import { createCipheriv, createDecipheriv, randomBytes } from 'crypto';

// ============================================================================
// PER-TENANT SECRETS (CRM API keys, Zapier webhooks, etc.)
// Encrypted at rest using AES-256-GCM. Key stored in environment variable.
// Cached in Redis with 1-hour TTL.
// NEVER store plaintext secrets in the tenant config column.
// ============================================================================

const redis = Redis.fromEnv();
const supabaseAdmin = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

const ENCRYPTION_KEY = Buffer.from(process.env.SECRETS_ENCRYPTION_KEY!, 'hex'); // 32 bytes (256 bits)
const CACHE_TTL = 3600; // 1 hour

// ── AES-256-GCM Encryption ──────────────────────────────────────────────────

function encrypt(plaintext: string): string {
  const iv = randomBytes(12); // 96-bit IV for GCM
  const cipher = createCipheriv('aes-256-gcm', ENCRYPTION_KEY, iv);

  const encrypted = Buffer.concat([cipher.update(plaintext, 'utf8'), cipher.final()]);

  const authTag = cipher.getAuthTag(); // 128-bit authentication tag

  // Format: iv:authTag:ciphertext (all hex-encoded)
  return [iv.toString('hex'), authTag.toString('hex'), encrypted.toString('hex')].join(':');
}

function decrypt(ciphertext: string): string {
  const [ivHex, authTagHex, encryptedHex] = ciphertext.split(':');

  const iv = Buffer.from(ivHex, 'hex');
  const authTag = Buffer.from(authTagHex, 'hex');
  const encrypted = Buffer.from(encryptedHex, 'hex');

  const decipher = createDecipheriv('aes-256-gcm', ENCRYPTION_KEY, iv);
  decipher.setAuthTag(authTag);

  const decrypted = Buffer.concat([decipher.update(encrypted), decipher.final()]);

  return decrypted.toString('utf8');
}

// ── Public API ───────────────────────────────────────────────────────────────

export async function getTenantSecret(tenantId: string, secretKey: string): Promise<string | null> {
  const cacheKey = `secret:${tenantId}:${secretKey}`;

  // Check Redis cache first
  const cached = await redis.get<string>(cacheKey);
  if (cached) return cached;

  // Fetch from DB
  const { data } = await supabaseAdmin
    .from('tenant_secrets')
    .select('value_encrypted')
    .eq('tenant_id', tenantId)
    .eq('key', secretKey)
    .single();

  if (!data?.value_encrypted) return null;

  // Decrypt
  let decrypted: string;
  try {
    decrypted = decrypt(data.value_encrypted);
  } catch (err) {
    console.error(`[Secrets] Decryption failed for ${tenantId}:${secretKey}`, err);
    return null;
  }

  // Cache decrypted value (safe in Redis — Redis traffic is encrypted in transit via TLS)
  await redis.setex(cacheKey, CACHE_TTL, decrypted);

  return decrypted;
}

export async function setTenantSecret(
  tenantId: string,
  secretKey: string,
  value: string
): Promise<void> {
  const encrypted = encrypt(value);

  await supabaseAdmin.from('tenant_secrets').upsert(
    {
      tenant_id: tenantId,
      key: secretKey,
      value_encrypted: encrypted,
      updated_at: new Date().toISOString(),
    },
    { onConflict: 'tenant_id,key' }
  );

  // Bust cache
  const cacheKey = `secret:${tenantId}:${secretKey}`;
  await redis.del(cacheKey);
}

export async function deleteTenantSecret(tenantId: string, secretKey: string): Promise<void> {
  await supabaseAdmin
    .from('tenant_secrets')
    .delete()
    .eq('tenant_id', tenantId)
    .eq('key', secretKey);

  const cacheKey = `secret:${tenantId}:${secretKey}`;
  await redis.del(cacheKey);
}

export async function listTenantSecretKeys(tenantId: string): Promise<string[]> {
  const { data } = await supabaseAdmin
    .from('tenant_secrets')
    .select('key')
    .eq('tenant_id', tenantId)
    .order('key');

  return (data ?? []).map((row) => row.key);
}
```

---
