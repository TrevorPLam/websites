### 15.4 Complete Middleware

**File:** `apps/*/src/middleware.ts` — the unified middleware integrating all security layers.

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server';
import { resolveTenant } from '@repo/multi-tenant/resolve-tenant';
import { applySecurityHeaders } from '@repo/security/headers';
import { checkRateLimit } from '@repo/security/rate-limit';
import { applyABTests } from '@repo/analytics/ab-testing';

// ============================================================================
// ROUTE MATCHERS
// ============================================================================

const isPublicRoute = createRouteMatcher([
  '/',
  '/about(.*)',
  '/services(.*)',
  '/blog(.*)',
  '/contact(.*)',
  '/api/contact',
  '/api/webhooks/(.*)',
  '/api/draft-mode/(.*)',
  '/api/jobs/(.*)', // Protected by QStash signature, not Clerk
  '/sitemap.xml',
  '/robots.txt',
  '/llms.txt',
  '/llms-full.txt',
  '/ai-context.json',
  '/og(.*)',
  '/auth/(.*)',
  '/sign-in(.*)',
  '/sign-up(.*)',
]);

const isAuthRoute = createRouteMatcher(['/auth/(.*)', '/sign-in(.*)', '/sign-up(.*)']);

const isAdminRoute = createRouteMatcher(['/admin(.*)']);

const isAPIRoute = createRouteMatcher(['/api/(.*)']);

const isWebhookRoute = createRouteMatcher(['/api/webhooks/(.*)']);

// ============================================================================
// MAIN MIDDLEWARE
// Order matters: security headers → rate limiting → tenant resolution → auth
// ============================================================================

export default clerkMiddleware(async (auth, request: NextRequest) => {
  const { pathname, hostname } = request.nextUrl;
  const isDashboard = hostname.includes('portal.') || hostname.includes('app.');

  // ── Step 1: Block CVE-2025-29927 header injection ─────────────────────────
  // Defense against middleware bypass via crafted subrequest header [web:24]
  if (request.headers.has('x-middleware-subrequest')) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  // ── Step 2: Apply security headers (nonce generated per request) ──────────
  let response = NextResponse.next();
  const { response: securedResponse, nonce } = applySecurityHeaders(request, response, {
    environment: (process.env.VERCEL_ENV ?? 'development') as any,
    isDashboard,
  });
  response = securedResponse;

  // Forward nonce to Server Components (reads from headers in layout)
  response.headers.set('X-Nonce', nonce);

  // ── Step 3: Rate limiting ────────────────────────────────────────────────

  // Webhook endpoints: separate limit (Stripe bursts)
  if (isWebhookRoute(request)) {
    const limited = await checkRateLimit(request, 'webhook');
    if (limited) return limited;
  }
  // API routes: standard API limit
  else if (isAPIRoute(request)) {
    const limited = await checkRateLimit(request, 'api');
    if (limited) return limited;
  }
  // All other routes: global IP limit
  else {
    const limited = await checkRateLimit(request, 'global');
    if (limited) return limited;
  }

  // ── Step 4: Tenant resolution (custom domain / subdomain routing) ─────────
  const tenantContext = await resolveTenant(request);

  if (!tenantContext) {
    // Unknown domain — 404 or redirect to marketing site
    return NextResponse.rewrite(new URL('/404', request.url));
  }

  // Inject tenant context into request headers (reads in Server Components)
  response.headers.set('X-Tenant-Id', tenantContext.tenantId);
  response.headers.set('X-Tenant-Slug', tenantContext.slug);
  response.headers.set('X-Billing-Tier', tenantContext.billingTier);

  // ── Step 5: Suspended tenant gate ────────────────────────────────────────
  if (
    tenantContext.status === 'suspended' &&
    !isPublicRoute(request) &&
    !pathname.startsWith('/billing')
  ) {
    return NextResponse.redirect(new URL('/suspended', request.url));
  }

  // ── Step 6: Clerk auth (protected routes only) ────────────────────────────
  if (!isPublicRoute(request)) {
    const { userId } = await auth();

    if (!userId) {
      return NextResponse.redirect(new URL('/sign-in', request.url));
    }

    // Admin-only routes require admin role
    if (isAdminRoute(request)) {
      const { sessionClaims } = await auth();
      const userRole = (sessionClaims?.metadata as any)?.role;

      if (userRole !== 'super_admin') {
        return NextResponse.redirect(new URL('/dashboard', request.url));
      }
    }

    response.headers.set('X-User-Id', userId);
  }

  // ── Step 7: A/B testing (cookie assignment — zero CLS) ───────────────────
  response = await applyABTests(request, response, tenantContext.tenantId);

  return response;
});

export const config = {
  matcher: [
    // Match all paths except Next.js internals and static files
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp|ico|css|js|woff|woff2)).*)',
  ],
};
```

---
