### 7.2 Complete Tenant Resolution — `packages/multi-tenant/src/resolve-tenant.ts`

```typescript
import { NextRequest } from 'next/server';
import { Redis } from '@upstash/redis';
import { db } from '@repo/db';
import type { SiteConfig } from '@repo/config-schema';

const redis = Redis.fromEnv();
const CACHE_TTL_SECONDS = 300; // 5 minutes — balance freshness vs. DB load

export type TenantResolution =
  | { success: true; tenantId: string; tenantConfig: SiteConfig }
  | { success: false; reason: 'not_found' | 'invalid_host' };

// ============================================================================
// EXTRACT IDENTIFIER FROM REQUEST
// Supports: subdomain, custom domain, path prefix
// Priority: custom domain → subdomain → path prefix
// ============================================================================

function extractTenantIdentifier(
  request: NextRequest
): { type: 'subdomain' | 'custom_domain' | 'path'; value: string } | null {
  const host = request.headers.get('host') ?? '';
  const pathname = request.nextUrl.pathname;

  // Agency platform base domains (not client domains)
  const BASE_DOMAINS = [
    'youragency.com',
    'www.youragency.com',
    'localhost:3000',
    'vercel.app', // Preview deployments
  ];

  const isBaseDomain = BASE_DOMAINS.some((base) => host === base || host.endsWith('.' + base));

  // --- Custom Domain: Not a base domain and not a subdomain of base ---
  // e.g., host = "acmelaw.com" or "www.acmelaw.com"
  if (!isBaseDomain && !host.endsWith('.youragency.com')) {
    // Strip "www." prefix for canonical lookup
    const cleanHost = host.replace(/^www\./, '');
    return { type: 'custom_domain', value: cleanHost };
  }

  // --- Subdomain: e.g., "acme-law.youragency.com" ---
  if (host.endsWith('.youragency.com')) {
    const subdomain = host.replace('.youragency.com', '');
    // Exclude reserved subdomains
    const RESERVED = ['www', 'admin', 'portal', 'api', 'mail', 'cdn'];
    if (RESERVED.includes(subdomain)) return null;
    return { type: 'subdomain', value: subdomain };
  }

  // --- Path prefix: e.g., "/sites/acme-law/..." ---
  const pathMatch = pathname.match(/^\/sites\/([a-z0-9-]+)(\/.*)?$/);
  if (pathMatch) {
    return { type: 'path', value: pathMatch[1] };
  }

  return null;
}

// ============================================================================
// RESOLVE TENANT (with Redis cache)
// ============================================================================

export async function resolveTenant(request: NextRequest): Promise<TenantResolution> {
  const identifier = extractTenantIdentifier(request);

  if (!identifier) {
    return { success: false, reason: 'invalid_host' };
  }

  // --- Cache key ---
  const cacheKey = `tenant:resolve:${identifier.type}:${identifier.value}`;

  // --- Check Redis cache first ---
  const cached = await redis.get<{ tenantId: string; tenantConfig: SiteConfig }>(cacheKey);
  if (cached) {
    return { success: true, tenantId: cached.tenantId, tenantConfig: cached.tenantConfig };
  }

  // --- Database lookup ---
  let query = db.from('tenants').select('id, config');

  if (identifier.type === 'subdomain') {
    query = query.eq('subdomain', identifier.value);
  } else if (identifier.type === 'custom_domain') {
    query = query.eq('custom_domain', identifier.value);
  } else {
    // Path-based
    query = query.eq('subdomain', identifier.value);
  }

  const { data: tenant, error } = await query.single();

  if (error || !tenant) {
    return { success: false, reason: 'not_found' };
  }

  const result = {
    tenantId: tenant.id,
    tenantConfig: tenant.config as SiteConfig,
  };

  // --- Cache the resolution for 5 minutes ---
  await redis.set(cacheKey, result, { ex: CACHE_TTL_SECONDS });

  return { success: true, ...result };
}

// ============================================================================
// INVALIDATE CACHE (called when tenant config changes)
// ============================================================================

export async function invalidateTenantCache(tenantId: string): Promise<void> {
  // Get tenant's identifiers to delete all cache keys
  const { data: tenant } = await db
    .from('tenants')
    .select('subdomain, custom_domain')
    .eq('id', tenantId)
    .single();

  if (!tenant) return;

  const keysToDelete = [
    `tenant:resolve:subdomain:${tenant.subdomain}`,
    tenant.custom_domain ? `tenant:resolve:custom_domain:${tenant.custom_domain}` : null,
    `tenant:resolve:path:${tenant.subdomain}`,
    `tenant:billing:${tenantId}`,
  ].filter(Boolean) as string[];

  if (keysToDelete.length) {
    await redis.del(...keysToDelete);
  }
}
```

---
