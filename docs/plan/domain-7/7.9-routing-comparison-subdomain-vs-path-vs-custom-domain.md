### 7.9 Routing Comparison — Subdomain vs Path vs Custom Domain

The full decision logic is encoded in `extractTenantIdentifier()` (§7.2 above), but here is the implementation detail for each routing mode:

**Subdomain routing — the rewrite pattern:** [storyie](https://storyie.com/blog/multi-tenant-subdomain-routing)

```typescript
// middleware.ts addition: rewrite subdomain requests to shared route tree
if (identifier.type === 'subdomain') {
  const url = request.nextUrl.clone();
  // Rewrite: acme-law.youragency.com/about
  //       → youragency.com/sites/acme-law/about
  // This lets a single Next.js app serve all subdomains
  url.pathname = `/sites/${identifier.value}${request.nextUrl.pathname}`;
  return NextResponse.rewrite(url);
}
```

**App Router directory structure for rewritten paths:**

```
sites/[base-app]/src/app/
├── sites/
│   └── [tenant]/              ← Dynamic segment receives subdomain value
│       ├── page.tsx           ← Homepage
│       ├── about/
│       │   └── page.tsx
│       ├── services/
│       │   └── page.tsx
│       └── contact/
│           └── page.tsx
└── suspended/
    └── page.tsx
```

**OR — the cleaner production approach — a shared app with tenant context from headers:**

```typescript
// sites/[base-app]/src/app/page.tsx
// One file serves ALL tenants (tenantId from headers, not URL params)
import { headers } from 'next/headers';
import { HomePageShell } from '@/pages/home';

export default async function Page() {
  const tenantId = (await headers()).get('X-Tenant-Id')!;
  return <HomePageShell tenantId={tenantId} />;
}
```

This is the preferred approach: **no URL params, no `[tenant]` dynamic routes** — tenant context flows through headers only. Result: cleaner routing tree, fewer dynamic segments, better `use cache` compatibility.

---
