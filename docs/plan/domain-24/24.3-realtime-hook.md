# 24.3 Realtime Hook

**File:** `packages/realtime/src/use-realtime-leads.ts`

```typescript
'use client';

import { useEffect, useRef, useCallback } from 'react';
import { createClient } from '@supabase/supabase-js';
import type { RealtimeChannel } from '@supabase/supabase-js';

// ============================================================================
// REALTIME LEADS HOOK
// Subscribes to INSERT events on the `leads` table filtered by tenant_id.
// Automatically reconnects on visibility change (handles tab sleep).
// ============================================================================

export interface RealtimeLead {
  id: string;
  tenant_id: string;
  name: string;
  email: string;
  phone: string | null;
  message: string;
  score: number;
  source: string;
  status: string;
  created_at: string;
  metadata: Record<string, unknown>;
}

interface UseRealtimeLeadsOptions {
  tenantId: string;
  onNewLead: (lead: RealtimeLead) => void;
  onLeadUpdated?: (lead: RealtimeLead) => void;
  enabled?: boolean; // Feature flag: only enabled on Professional+ plans
}

// Singleton Supabase client for realtime (separate from data client)
// Using anon key + user's session for RLS enforcement
const getRealtimeClient = () =>
  createClient(process.env.NEXT_PUBLIC_SUPABASE_URL!, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!);

export function useRealtimeLeads({
  tenantId,
  onNewLead,
  onLeadUpdated,
  enabled = true,
}: UseRealtimeLeadsOptions) {
  const channelRef = useRef<RealtimeChannel | null>(null);
  const supabaseRef = useRef(getRealtimeClient());
  const onNewLeadRef = useRef(onNewLead);
  const onLeadUpdatedRef = useRef(onLeadUpdated);

  // Keep callbacks current without re-subscribing
  useEffect(() => {
    onNewLeadRef.current = onNewLead;
  }, [onNewLead]);
  useEffect(() => {
    onLeadUpdatedRef.current = onLeadUpdated;
  }, [onLeadUpdated]);

  const subscribe = useCallback(() => {
    if (!enabled || !tenantId) return;

    // Clean up existing channel before creating new one
    if (channelRef.current) {
      supabaseRef.current.removeChannel(channelRef.current);
    }

    // Channel name must be unique per tab (prevent duplicate subscriptions)
    const channelName = `leads-feed-${tenantId}-${Math.random().toString(36).slice(2)}`;

    const channel = supabaseRef.current
      .channel(channelName)
      .on(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'leads',
          // Server-side filter: only receive this tenant's leads
          // RLS enforces this at the DB level; filter reduces bandwidth
          filter: `tenant_id=eq.${tenantId}`,
        },
        (payload) => {
          const lead = payload.new as RealtimeLead;
          onNewLeadRef.current(lead);
        }
      )
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'leads',
          filter: `tenant_id=eq.${tenantId}`,
        },
        (payload) => {
          const lead = payload.new as RealtimeLead;
          onLeadUpdatedRef.current?.(lead);
        }
      )
      .subscribe((status, error) => {
        if (status === 'SUBSCRIBED') {
          console.log(`[Realtime] Leads channel connected: ${channelName}`);
        }
        if (status === 'CHANNEL_ERROR') {
          console.error(`[Realtime] Channel error:`, error);
          // Auto-reconnect after 5 seconds on error
          setTimeout(subscribe, 5000);
        }
        if (status === 'TIMED_OUT') {
          console.warn('[Realtime] Channel timed out, reconnecting...');
          setTimeout(subscribe, 2000);
        }
      });

    channelRef.current = channel;
  }, [tenantId, enabled]);

  // Initial subscription
  useEffect(() => {
    subscribe();

    // Reconnect on tab focus (WebSocket may have been dropped during tab sleep)
    const handleVisibilityChange = () => {
      if (document.visibilityState === 'visible') {
        subscribe();
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);

    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      if (channelRef.current) {
        supabaseRef.current.removeChannel(channelRef.current);
      }
    };
  }, [subscribe]);
}
```
