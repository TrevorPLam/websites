### 12.2 QStash Client Setup

**File:** `packages/jobs/src/client.ts`

```typescript
import { Client as QStashClient, Receiver } from '@upstash/qstash';

export const qstash = new QStashClient({
  token: process.env.QSTASH_TOKEN!,
});

// Used to verify QStash requests to our endpoints (prevents unauthorized calls)
export const qstashReceiver = new Receiver({
  currentSigningKey: process.env.QSTASH_CURRENT_SIGNING_KEY!,
  nextSigningKey: process.env.QSTASH_NEXT_SIGNING_KEY!,
});

// ============================================================================
// JOB DEFINITIONS (type-safe payloads)
// ============================================================================

export type JobType =
  | 'email.lead_digest'
  | 'email.billing_receipt'
  | 'crm.sync_lead'
  | 'gdpr.delete_tenant'
  | 'report.weekly'
  | 'sitemap.rebuild'
  | 'booking.reminder'
  | 'booking.followup';

export type JobPayloadMap = {
  'email.lead_digest': { tenantId: string; date: string };
  'email.billing_receipt': {
    tenantId: string;
    invoiceId: string;
    amountPaid: number;
    currency: string;
    hostedInvoiceUrl: string | null;
  };
  'crm.sync_lead': {
    tenantId: string;
    leadId: string;
    crmType: 'hubspot' | 'zapier' | 'gohighlevel';
  };
  'gdpr.delete_tenant': { tenantId: string; reason: string };
  'report.weekly': { tenantId: string };
  'sitemap.rebuild': { tenantId: string };
  'booking.reminder': { tenantId: string; bookingId: string; reminderType: '24h' | '1h' };
  'booking.followup': { tenantId: string; bookingId: string };
};

const JOB_ENDPOINTS: Record<JobType, string> = {
  'email.lead_digest': '/api/jobs/email/lead-digest',
  'email.billing_receipt': '/api/jobs/email/billing-receipt',
  'crm.sync_lead': '/api/jobs/crm/sync-lead',
  'gdpr.delete_tenant': '/api/jobs/gdpr/delete-tenant',
  'report.weekly': '/api/jobs/reports/weekly',
  'sitemap.rebuild': '/api/jobs/sitemap/rebuild',
  'booking.reminder': '/api/jobs/booking/reminder',
  'booking.followup': '/api/jobs/booking/followup',
};

// ============================================================================
// ENQUEUE HELPER (type-safe, URL auto-resolved)
// ============================================================================

export async function enqueue<T extends JobType>(
  jobType: T,
  payload: JobPayloadMap[T],
  options?: {
    delaySeconds?: number;
    notBefore?: Date; // Schedule for specific time
    retries?: number;
    deduplicationId?: string;
  }
): Promise<void> {
  const endpoint = JOB_ENDPOINTS[jobType];
  const baseUrl = process.env.NEXT_PUBLIC_APP_URL!;

  await qstash.publishJSON({
    url: `${baseUrl}${endpoint}`,
    body: payload,
    retries: options?.retries ?? 3,
    ...(options?.delaySeconds ? { delay: options.delaySeconds } : {}),
    ...(options?.notBefore ? { notBefore: Math.floor(options.notBefore.getTime() / 1000) } : {}),
    ...(options?.deduplicationId ? { deduplicationId: options.deduplicationId } : {}),
  });
}

// ============================================================================
// SCHEDULE HELPER (cron-based recurring jobs)
// Schedules are created once at startup (or via admin UI)
// ============================================================================

export async function createSchedule(
  jobType: JobType,
  cron: string,
  payload: Record<string, unknown>
): Promise<string> {
  const baseUrl = process.env.NEXT_PUBLIC_APP_URL!;
  const endpoint = JOB_ENDPOINTS[jobType];

  const schedule = await qstash.schedules.create({
    destination: `${baseUrl}${endpoint}`,
    cron,
    body: JSON.stringify(payload),
    headers: { 'Content-Type': 'application/json' },
    retries: 2,
  });

  return schedule.scheduleId;
}
```

---
