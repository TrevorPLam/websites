### 31.3 Offline-Aware Contact Form Hook

**File:** `packages/ui/src/hooks/use-offline-form.ts`

```typescript
'use client';

import { useState, useEffect, useCallback } from 'react';
import { openDB, type IDBPDatabase } from 'idb';

// ============================================================================
// OFFLINE FORM HOOK
// Detects online/offline state and queues form submissions in IndexedDB
// when offline. The service worker's BackgroundSync replays them.
// Falls back gracefully if service worker / Background Sync not supported.
// ============================================================================

export interface PendingSubmission {
  id: string;
  url: string;
  body: Record<string, unknown>;
  timestamp: number;
  retryCount: number;
}

const DB_NAME = 'offline-form-store';
const STORE_NAME = 'pending-submissions';

let dbInstance: IDBPDatabase | null = null;

async function getDB(): Promise<IDBPDatabase> {
  if (dbInstance) return dbInstance;

  dbInstance = await openDB(DB_NAME, 1, {
    upgrade(db) {
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
      }
    },
  });

  return dbInstance;
}

export function useOfflineForm(apiUrl: string) {
  const [isOnline, setIsOnline] = useState(
    typeof navigator !== 'undefined' ? navigator.onLine : true
  );
  const [pendingCount, setPendingCount] = useState(0);
  const [syncedOfflineData, setSyncedOfflineData] = useState(false);

  // Track online state
  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  // Listen for background sync completion message from service worker
  useEffect(() => {
    if (!('serviceWorker' in navigator)) return;

    const handleMessage = (event: MessageEvent) => {
      if (event.data?.type === 'BACKGROUND_SYNC_COMPLETE') {
        setSyncedOfflineData(true);
        loadPendingCount();
        // Auto-clear notification after 5s
        setTimeout(() => setSyncedOfflineData(false), 5000);
      }
    };

    navigator.serviceWorker.addEventListener('message', handleMessage);
    return () => navigator.serviceWorker.removeEventListener('message', handleMessage);
  }, []);

  const loadPendingCount = useCallback(async () => {
    try {
      const db = await getDB();
      const all = await db.getAll(STORE_NAME);
      setPendingCount(all.length);
    } catch {
      setPendingCount(0);
    }
  }, []);

  useEffect(() => {
    loadPendingCount();
  }, [loadPendingCount]);

  // Submit: try network first, fall back to IndexedDB queue
  const submit = useCallback(
    async (
      formData: Record<string, unknown>
    ): Promise<{ success: boolean; queued: boolean; error?: string }> => {
      // Attempt network submission
      if (isOnline) {
        try {
          const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(formData),
          });

          if (response.ok) {
            return { success: true, queued: false };
          }

          // Non-2xx but connected — don't queue (validation error, etc.)
          const error = await response.json().catch(() => ({}));
          return {
            success: false,
            queued: false,
            error: error.message ?? `Server error: ${response.status}`,
          };
        } catch {
          // Network error despite navigator.onLine — fall through to queue
        }
      }

      // Queue in IndexedDB for background sync
      try {
        const db = await getDB();
        const submission: PendingSubmission = {
          id: `${Date.now()}-${Math.random().toString(36).slice(2)}`,
          url: apiUrl,
          body: formData,
          timestamp: Date.now(),
          retryCount: 0,
        };

        await db.add(STORE_NAME, submission);

        // Register background sync (if supported)
        if ('serviceWorker' in navigator && 'SyncManager' in window) {
          const registration = await navigator.serviceWorker.ready;
          await (registration as any).sync.register('contact-form-queue');
        }

        setPendingCount((prev) => prev + 1);

        return { success: true, queued: true };
      } catch (err: any) {
        return { success: false, queued: false, error: err.message };
      }
    },
    [apiUrl, isOnline]
  );

  return {
    isOnline,
    submit,
    pendingCount,
    syncedOfflineData,
  };
}
```

---
