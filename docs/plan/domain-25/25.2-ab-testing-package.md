# 25.2 A/B Testing Package

**File:** `packages/analytics/src/ab-testing.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { get } from '@vercel/edge-config';
import { Redis } from '@upstash/redis';

const redis = Redis.fromEnv();

// ============================================================================
// A/B TESTING ENGINE (Edge Middleware)
// ============================================================================

export interface ABExperiment {
  id: string;
  name: string;
  tenantId: string | 'global'; // 'global' applies to all tenants
  path: string; // Pathname pattern to test, e.g. '/' or '/services/*'
  variants: ABVariant[];
  status: 'active' | 'paused' | 'concluded';
  startedAt: string;
  concludedAt?: string;
  winnerVariantId?: string;
}

export interface ABVariant {
  id: string; // e.g. 'control', 'variant-a', 'variant-b'
  weight: number; // 0–100 (must sum to 100 across all variants)
  description?: string;
}

const COOKIE_NAME = 'ab_assignments'; // Single cookie maps experimentId → variantId
const COOKIE_MAX_AGE = 60 * 60 * 24 * 30; // 30 days

// ============================================================================
// APPLY A/B TESTS IN MIDDLEWARE
// Called once per request — reads Edge Config for experiment definitions
// ============================================================================

export async function applyABTests(
  request: NextRequest,
  response: NextResponse,
  tenantId: string
): Promise<NextResponse> {
  const { pathname } = request.nextUrl;

  // Fetch active experiments from Edge Config (~0ms)
  let experiments: ABExperiment[] = [];
  try {
    const all = await get<ABExperiment[]>('abExperiments');
    experiments = (all ?? []).filter(
      (e) =>
        e.status === 'active' &&
        (e.tenantId === 'global' || e.tenantId === tenantId) &&
        pathMatchesPattern(pathname, e.path)
    );
  } catch {
    // Edge Config unavailable — skip A/B testing, don't block request
    return response;
  }

  if (experiments.length === 0) return response;

  // Read existing assignments from cookie
  const cookieValue = request.cookies.get(COOKIE_NAME)?.value;
  let assignments: Record<string, string> = {};
  try {
    assignments = cookieValue ? JSON.parse(Buffer.from(cookieValue, 'base64').toString()) : {};
  } catch {
    assignments = {};
  }

  let assignmentsChanged = false;

  for (const experiment of experiments) {
    if (assignments[experiment.id]) continue; // Already assigned

    // Assign variant deterministically based on IP + experiment ID
    // (same IP always gets same variant — consistent experience)
    const ip = request.headers.get('x-forwarded-for')?.split(',')[0] ?? '0.0.0.0';
    const variantId = assignVariant(ip, experiment.id, experiment.variants);

    assignments[experiment.id] = variantId;
    assignmentsChanged = true;

    // Track assignment in Redis for analytics (async — don't await)
    redis.hincrby(`ab:${experiment.id}:assignments`, variantId, 1).catch(() => {});
  }

  if (assignmentsChanged) {
    const encoded = Buffer.from(JSON.stringify(assignments)).toString('base64');
    response.cookies.set(COOKIE_NAME, encoded, {
      httpOnly: true,
      sameSite: 'lax',
      secure: process.env.NODE_ENV === 'production',
      maxAge: COOKIE_MAX_AGE,
      path: '/',
    });
  }

  // Inject assignments as request header for Server Components to read
  const assignmentsHeader = JSON.stringify(assignments);
  response.headers.set('X-AB-Assignments', assignmentsHeader);

  return response;
}

// ── Deterministic variant assignment ─────────────────────────────────────────
// djb2 hash of IP + experimentId → maps to variant based on cumulative weights

function assignVariant(ip: string, experimentId: string, variants: ABVariant[]): string {
  const seed = `${ip}:${experimentId}`;
  let hash = 5381;
  for (const char of seed) {
    hash = (hash * 33) ^ char.charCodeAt(0);
  }
  const bucket = Math.abs(hash) % 100; // 0–99

  let cumulative = 0;
  for (const variant of variants) {
    cumulative += variant.weight;
    if (bucket < cumulative) return variant.id;
  }
  return variants[0]?.id ?? 'control';
}

// ── Path pattern matching (supports * wildcard) ───────────────────────────────

function pathMatchesPattern(pathname: string, pattern: string): boolean {
  if (pattern === '*') return true;
  if (pattern === pathname) return true;
  if (pattern.endsWith('*')) {
    return pathname.startsWith(pattern.slice(0, -1));
  }
  return false;
}

// ============================================================================
// SERVER COMPONENT HELPER
// Reads variant assignment from injected header
// ============================================================================

import { headers } from 'next/headers';

export async function getABVariant(experimentId: string): Promise<string | null> {
  const headersList = await headers();
  const assignmentsHeader = headersList.get('X-AB-Assignments');
  if (!assignmentsHeader) return null;

  try {
    const assignments = JSON.parse(assignmentsHeader);
    return assignments[experimentId] ?? null;
  } catch {
    return null;
  }
}

// ============================================================================
// CONVERSION TRACKING
// Called from Server Actions or Route Handlers when a conversion event fires
// ============================================================================

export async function trackABConversion(
  experimentId: string,
  variantId: string,
  conversionType: 'lead_submitted' | 'phone_clicked' | 'booking_created'
): Promise<void> {
  // Increment conversion counter in Redis
  await redis.hincrby(`ab:${experimentId}:conversions:${conversionType}`, variantId, 1);
}

// ============================================================================
// ADMIN: Get experiment results
// ============================================================================

export async function getExperimentResults(experimentId: string) {
  const [assignments, leadConversions, phoneConversions] = await Promise.all([
    redis.hgetall(`ab:${experimentId}:assignments`),
    redis.hgetall(`ab:${experimentId}:conversions:lead_submitted`),
    redis.hgetall(`ab:${experimentId}:conversions:phone_clicked`),
  ]);

  const variants = Object.keys(assignments ?? {});

  return variants.map((variantId) => {
    const assigned = Number(assignments?.[variantId] ?? 0);
    const leads = Number(leadConversions?.[variantId] ?? 0);
    const phoneClicks = Number(phoneConversions?.[variantId] ?? 0);

    return {
      variantId,
      assigned,
      leads,
      phoneClicks,
      leadConversionRate: assigned > 0 ? (leads / assigned) * 100 : 0,
      phoneConversionRate: assigned > 0 ? (phoneClicks / assigned) * 100 : 0,
    };
  });
}
```
