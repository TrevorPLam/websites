### 22.2 AI Chat API Route (Streaming, Edge)

**File:** `apps/*/src/app/api/chat/route.ts`

```typescript
import { streamText, tool } from 'ai';
import { openai } from '@ai-sdk/openai';
import { NextRequest } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { z } from 'zod';
import { db } from '@repo/db';
import { checkRateLimit } from '@repo/security/rate-limit';

export const runtime = 'edge';
export const maxDuration = 30;

// Per-tenant chat rate limit: 20 messages per hour per IP
// (Prevents API cost abuse from single visitor)
const MAX_MESSAGES_PER_SESSION = 15;

const supabaseAdmin = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

// ============================================================================
// SYSTEM PROMPT BUILDER
// Injects tenant context: services, hours, pricing, location
// ============================================================================

async function buildSystemPrompt(tenantId: string): Promise<string> {
  const { data: tenant } = await db.from('tenants').select('config').eq('id', tenantId).single();

  if (!tenant?.config) {
    return 'You are a helpful assistant for a local service business.';
  }

  const config = tenant.config as any;
  const identity = config.identity ?? {};
  const services = identity.services ?? [];
  const hours = identity.hours ?? [];

  const serviceList = services.map((s: any) => `- ${s.name}: ${s.description}`).join('\n');

  const hoursList = hours
    .map((h: any) => `${h.days?.join(', ')}: ${h.opens}–${h.closes}`)
    .join('\n');

  return `
You are ${identity.siteName ?? 'a local business'}'s AI assistant on their website.
Your job: answer visitor questions concisely, capture their contact info, and schedule appointments.

BUSINESS INFORMATION:
Name: ${identity.siteName ?? 'Our Business'}
Industry: ${identity.industry ?? 'services'}
Phone: ${identity.contact?.phone ?? 'See website'}
Email: ${identity.contact?.email ?? 'See website'}
Location: ${identity.address ? `${identity.address.city}, ${identity.address.state}` : 'See website'}

SERVICES OFFERED:
${serviceList || 'Contact us for a full list of services.'}

HOURS OF OPERATION:
${hoursList || 'Please call or check our website for current hours.'}

SERVICE AREAS:
${identity.serviceAreas?.join(', ') ?? 'Contact us for service area coverage.'}

GUIDELINES:
- Keep responses under 3 sentences when possible — visitors skim, not read
- Always offer to collect their name/phone/email to have someone call them back
- If they ask about pricing, give a range if known or say "We'd need to assess your specific situation for an accurate quote"
- If they ask to schedule, use the schedule_appointment tool
- If they share contact info, use the capture_lead tool
- Never make up prices, hours, or services not listed above
- Respond in a warm, professional tone — this is a service business, not a tech startup
- If you cannot answer a question confidently, say "Great question — let me have [business owner name] give you a call to walk through that."
`.trim();
}

// ============================================================================
// RAG: Retrieve relevant content chunks for the user's question
// Uses pgvector similarity search on pre-embedded site content
// ============================================================================

async function retrieveContext(query: string, tenantId: string): Promise<string> {
  // Generate embedding for the user's query
  const embeddingResponse = await fetch('https://api.openai.com/v1/embeddings', {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model: 'text-embedding-3-small',
      input: query,
    }),
  });

  const { data: embedData } = await embeddingResponse.json();
  const embedding = embedData?.[0]?.embedding;

  if (!embedding) return '';

  // Vector similarity search (cosine distance) in pgvector
  const { data: chunks } = await supabaseAdmin.rpc('match_site_content', {
    query_embedding: embedding,
    match_tenant_id: tenantId,
    match_threshold: 0.78, // 78% similarity minimum
    match_count: 4, // Top 4 most relevant chunks
  });

  if (!chunks?.length) return '';

  return chunks.map((c: any) => c.content).join('\n\n---\n\n');
}

// ============================================================================
// ROUTE HANDLER
// ============================================================================

export async function POST(req: NextRequest) {
  // Rate limiting per IP
  const limited = await checkRateLimit(req, 'api');
  if (limited) return limited;

  const tenantId = req.headers.get('X-Tenant-Id');
  if (!tenantId) {
    return Response.json({ error: 'Missing tenant context' }, { status: 400 });
  }

  const { messages, sessionId } = await req.json();

  // Enforce session message limit (prevents infinite context window abuse)
  if (messages.length > MAX_MESSAGES_PER_SESSION) {
    return Response.json(
      { error: 'Message limit reached. Please refresh to start a new conversation.' },
      { status: 429 }
    );
  }

  // Build system prompt with tenant context
  const systemPrompt = await buildSystemPrompt(tenantId);

  // RAG: get relevant context for the last user message
  const lastUserMessage = messages.filter((m: any) => m.role === 'user').pop();
  let ragContext = '';
  if (lastUserMessage?.content) {
    ragContext = await retrieveContext(lastUserMessage.content, tenantId);
  }

  const systemWithContext = ragContext
    ? `${systemPrompt}\n\nRELEVANT SITE CONTENT:\n${ragContext}`
    : systemPrompt;

  const result = streamText({
    model: openai('gpt-4o-mini'), // Cost-optimized for chat widget
    system: systemWithContext,
    messages,
    maxTokens: 512, // Keep responses concise
    temperature: 0.4, // Lower temp = more consistent service info
    tools: {
      // ── Tool 1: Capture lead ─────────────────────────────────────────────
      capture_lead: tool({
        description:
          'Capture visitor contact information when they share it. Call this whenever a visitor provides their name, email, or phone number.',
        parameters: z.object({
          name: z.string().describe("Visitor's name"),
          email: z.string().email().optional().describe("Visitor's email address"),
          phone: z.string().optional().describe("Visitor's phone number"),
          intent: z
            .string()
            .describe('What the visitor is looking for (e.g., "HVAC repair", "free estimate")'),
          urgency: z.enum(['low', 'medium', 'high']).default('medium'),
        }),
        execute: async ({ name, email, phone, intent, urgency }) => {
          // Score based on available info
          const score = [
            email ? 25 : 0,
            phone ? 30 : 0,
            urgency === 'high' ? 20 : urgency === 'medium' ? 10 : 0,
            15, // Base score for engaging with chat
          ].reduce((a, b) => a + b, 0);

          const { data: lead } = await db
            .from('leads')
            .insert({
              tenant_id: tenantId,
              name,
              email: email?.toLowerCase() ?? null,
              phone: phone ?? null,
              message: intent,
              source: 'ai_chat',
              score: Math.min(score, 100),
              metadata: { sessionId, urgency, chatCaptured: true },
            })
            .select()
            .single();

          console.log(`[AI Chat] Lead captured: ${name}, tenant=${tenantId}`);

          return {
            success: true,
            message: lead
              ? `Perfect! I've got your info. Someone from the team will reach out to you ${urgency === 'high' ? 'shortly' : 'soon'}.`
              : 'Thanks! Your information has been noted.',
          };
        },
      }),

      // ── Tool 2: Schedule appointment ─────────────────────────────────────
      schedule_appointment: tool({
        description: 'Show the booking calendar when a visitor wants to schedule an appointment.',
        parameters: z.object({
          serviceType: z.string().describe('Type of service to book'),
          preferredTime: z.string().optional().describe('Preferred time if mentioned'),
        }),
        execute: async ({ serviceType, preferredTime }) => {
          // Fetch Cal.com username for this tenant
          const { getTenantSecret } = await import('@repo/security/secrets-manager');
          const calUsername = await getTenantSecret(tenantId, 'CAL_USERNAME');

          if (!calUsername) {
            return {
              showBooking: false,
              message:
                "I'd love to schedule that for you! Please call us directly at the number on our website, or I can collect your contact info and have someone call you.",
            };
          }

          return {
            showBooking: true,
            calLink: `${calUsername}/${serviceType.toLowerCase().replace(/\s+/g, '-')}`,
            message: `Here's our scheduling calendar for ${serviceType}. You can pick a time that works for you:`,
          };
        },
      }),

      // ── Tool 3: Get service info ──────────────────────────────────────────
      get_service_info: tool({
        description:
          'Retrieve detailed information about a specific service offered by the business.',
        parameters: z.object({
          serviceName: z.string().describe('Name of the service to look up'),
        }),
        execute: async ({ serviceName }) => {
          const { data: tenant } = await db
            .from('tenants')
            .select('config->identity->services')
            .eq('id', tenantId)
            .single();

          const services: any[] = (tenant as any)?.['config->identity->services'] ?? [];
          const match = services.find((s: any) =>
            s.name.toLowerCase().includes(serviceName.toLowerCase())
          );

          if (!match) {
            return {
              found: false,
              message: `I don't have specific details about "${serviceName}" on file, but we'd be happy to discuss it. Can I get your contact info?`,
            };
          }

          return {
            found: true,
            name: match.name,
            description: match.description,
            price: match.priceDisplay ?? 'Contact for pricing',
          };
        },
      }),
    },
    toolChoice: 'auto',
    onFinish: async ({ text, usage }) => {
      // Log token usage per tenant (for cost attribution)
      console.log(`[AI Chat] Finished: tenant=${tenantId}, tokens=${usage.totalTokens}`);
    },
  });

  return result.toDataStreamResponse();
}
```

---
