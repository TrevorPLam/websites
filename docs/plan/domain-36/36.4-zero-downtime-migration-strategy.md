### 36.4 Zero-Downtime Migration Strategy

Every database schema change follows a **three-phase expand/contract pattern**. This guarantees no downtime regardless of how long the Vercel deployment takes to propagate. [hrekov](https://hrekov.com/blog/vercel-migrations)

```
PHASE 1 — EXPAND (backward-compatible add)
Deploy migration BEFORE new code.
Old code + new code BOTH work against this schema.

  ✅ ADD column (nullable, with default) → safe
  ✅ ADD table → safe
  ✅ ADD index (CONCURRENTLY) → safe, non-blocking
  ✅ ADD constraint (NOT VALID, then VALIDATE separately) → safe

PHASE 2 — MIGRATE DATA (if needed)
Run a backfill job in a QStash background job.
Never UPDATE millions of rows in a single migration — use batched QStash jobs.

PHASE 3 — CONTRACT (remove old schema)
Deploy AFTER new code has been running 1+ deployment cycles.
Old code is no longer running — safe to remove the old shape.

  ✅ DROP old column → safe (new code no longer references it)
  ✅ DROP old table → safe
  ✅ RENAME column → safe (after dual-write period)
  ✅ ADD NOT NULL constraint → safe (after backfill confirmed)
```

**Safe migration example — adding `score_v2` column:**

```sql
-- ============================================================
-- MIGRATION: add score_v2 column (Phase 1 — Expand)
-- Deploy THIS migration BEFORE deploying the new code.
-- Both old and new app versions work with this schema.
-- ============================================================

-- Step 1: Add nullable column (old code ignores it, new code uses it)
ALTER TABLE leads
  ADD COLUMN IF NOT EXISTS score_v2 smallint DEFAULT NULL;

-- Step 2: Add index CONCURRENTLY (non-locking — safe on live table)
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_leads_score_v2
  ON leads(score_v2)
  WHERE score_v2 IS NOT NULL;

-- ============================================================
-- MIGRATION: backfill + enforce NOT NULL (Phase 3 — Contract)
-- Deploy AFTER new code has shipped and score_v2 is being written.
-- ============================================================

-- Step 1: Backfill historical rows (run as QStash batch job first,
--         migration only enforces constraint after backfill confirmed)
-- (See: packages/jobs/src/backfill-score-v2.ts)

-- Step 2: Enforce NOT NULL + drop old column
ALTER TABLE leads
  ALTER COLUMN score_v2 SET NOT NULL,
  ALTER COLUMN score_v2 SET DEFAULT 0;

-- Wait one more deploy cycle before dropping old 'score' column
-- ALTER TABLE leads DROP COLUMN score;   ← Phase 3, separate migration
```

---
