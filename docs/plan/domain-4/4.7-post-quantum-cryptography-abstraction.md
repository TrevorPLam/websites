### 4.7 Post-Quantum Cryptography Abstraction

**What it is:** NIST finalized FIPS 203 (ML-KEM), FIPS 204 (ML-DSA), and FIPS 205 (SLH-DSA) in August 2024 as the first post-quantum cryptography standards. The HQC algorithm is expected to be standardized in 2026. This abstraction layer allows the platform to migrate from RSA → Hybrid → ML-DSA without changing calling code. [cloudsecurityalliance](https://cloudsecurityalliance.org/blog/2024/08/15/nist-fips-203-204-and-205-finalized-an-important-step-towards-a-quantum-safe-future)

**File:** `packages/crypto-provider/src/provider-interface.ts`

```typescript
// ============================================================================
// CryptoProvider Interface
// Abstraction over RSA (current), Hybrid (transition), ML-DSA (FIPS 204 future)
// Migration timeline:
//   Phase 1 (Now–2026):   RSA-2048 / AES-256 (current)
//   Phase 2 (2026–2027):  Hybrid RSA + ML-DSA (dual-sign for interop)
//   Phase 3 (2027+):      ML-DSA only (FIPS 204 compliant)
// ============================================================================

export interface CryptoProvider {
  // Sign a payload (e.g., webhook signatures, audit log integrity)
  sign(payload: Uint8Array): Promise<Uint8Array>;

  // Verify a signature
  verify(payload: Uint8Array, signature: Uint8Array): Promise<boolean>;

  // Encrypt a value (e.g., per-tenant secrets, PII)
  encrypt(plaintext: string): Promise<string>;

  // Decrypt a value
  decrypt(ciphertext: string): Promise<string>;

  // Name of the algorithm (for audit logs)
  algorithmName: string;
}

// Configuration (set per tenant via site.config.ts compliance.pqc)
export type MigrationPhase = 'rsa' | 'hybrid' | 'pqc';

export function createCryptoProvider(phase: MigrationPhase): CryptoProvider {
  switch (phase) {
    case 'rsa':
      return new RSACryptoProvider();
    case 'hybrid':
      return new HybridCryptoProvider();
    case 'pqc':
      return new MLDSACryptoProvider();
    default:
      return new RSACryptoProvider();
  }
}
```

**File:** `packages/crypto-provider/src/rsa-provider.ts` (Phase 1 — Current)

```typescript
import { CryptoProvider } from './provider-interface';
import crypto from 'node:crypto';

export class RSACryptoProvider implements CryptoProvider {
  readonly algorithmName = 'RSA-2048-PSS / AES-256-GCM';

  private privateKey: crypto.KeyObject;
  private publicKey: crypto.KeyObject;

  constructor() {
    // Keys loaded from environment (rotated via runbook)
    this.privateKey = crypto.createPrivateKey(process.env.CRYPTO_PRIVATE_KEY!);
    this.publicKey = crypto.createPublicKey(process.env.CRYPTO_PUBLIC_KEY!);
  }

  async sign(payload: Uint8Array): Promise<Uint8Array> {
    const sign = crypto.createSign('RSA-SHA256');
    sign.update(payload);
    return new Uint8Array(
      sign.sign({ key: this.privateKey, padding: crypto.constants.RSA_PKCS1_PSS_PADDING })
    );
  }

  async verify(payload: Uint8Array, signature: Uint8Array): Promise<boolean> {
    const verify = crypto.createVerify('RSA-SHA256');
    verify.update(payload);
    return verify.verify(
      { key: this.publicKey, padding: crypto.constants.RSA_PKCS1_PSS_PADDING },
      Buffer.from(signature)
    );
  }

  async encrypt(plaintext: string): Promise<string> {
    // AES-256-GCM for symmetric encryption (RSA too slow for bulk data)
    const key = Buffer.from(process.env.CRYPTO_SYMMETRIC_KEY!, 'base64');
    const iv = crypto.randomBytes(12);
    const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);
    const encrypted = Buffer.concat([cipher.update(plaintext, 'utf8'), cipher.final()]);
    const tag = cipher.getAuthTag();
    return Buffer.concat([iv, tag, encrypted]).toString('base64');
  }

  async decrypt(ciphertext: string): Promise<string> {
    const buf = Buffer.from(ciphertext, 'base64');
    const iv = buf.subarray(0, 12);
    const tag = buf.subarray(12, 28);
    const encrypted = buf.subarray(28);
    const key = Buffer.from(process.env.CRYPTO_SYMMETRIC_KEY!, 'base64');
    const decipher = crypto.createDecipheriv('aes-256-gcm', key, iv);
    decipher.setAuthTag(tag);
    return Buffer.concat([decipher.update(encrypted), decipher.final()]).toString('utf8');
  }
}
```

**File:** `packages/crypto-provider/src/pqc-provider.ts` (Phase 3 — FIPS 204 ML-DSA)

```typescript
// NIST FIPS 204 ML-DSA implementation via @noble/post-quantum
// Activate when compliance.pqc.migrationPhase = 'pqc'
import { ml_dsa65 } from '@noble/post-quantum/ml-dsa';
import { CryptoProvider } from './provider-interface';
import crypto from 'node:crypto';

export class MLDSACryptoProvider implements CryptoProvider {
  readonly algorithmName = 'ML-DSA-65 (FIPS 204) / AES-256-GCM';

  private seed: Uint8Array;

  constructor() {
    // Seed from environment (32 bytes)
    this.seed = Buffer.from(process.env.ML_DSA_SEED!, 'hex');
  }

  private getKeyPair() {
    return ml_dsa65.keygen(this.seed);
  }

  async sign(payload: Uint8Array): Promise<Uint8Array> {
    const { secretKey } = this.getKeyPair();
    return ml_dsa65.sign(secretKey, payload);
  }

  async verify(payload: Uint8Array, signature: Uint8Array): Promise<boolean> {
    const { publicKey } = this.getKeyPair();
    return ml_dsa65.verify(publicKey, payload, signature);
  }

  // Encryption: ML-DSA is for signatures only; use AES-256-GCM for encryption
  async encrypt(plaintext: string): Promise<string> {
    const key = Buffer.from(process.env.CRYPTO_SYMMETRIC_KEY!, 'base64');
    const iv = crypto.randomBytes(12);
    const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);
    const encrypted = Buffer.concat([cipher.update(plaintext, 'utf8'), cipher.final()]);
    const tag = cipher.getAuthTag();
    return Buffer.concat([iv, tag, encrypted]).toString('base64');
  }

  async decrypt(ciphertext: string): Promise<string> {
    const buf = Buffer.from(ciphertext, 'base64');
    const iv = buf.subarray(0, 12);
    const tag = buf.subarray(12, 28);
    const encrypted = buf.subarray(28);
    const key = Buffer.from(process.env.CRYPTO_SYMMETRIC_KEY!, 'base64');
    const decipher = crypto.createDecipheriv('aes-256-gcm', key, iv);
    decipher.setAuthTag(tag);
    return Buffer.concat([decipher.update(encrypted), decipher.final()]).toString('utf8');
  }
}
```

**PQC Migration Timeline:**

| Phase      | Period    | Algorithm              | FIPS Standard  | Trigger                          |
| ---------- | --------- | ---------------------- | -------------- | -------------------------------- |
| **RSA**    | Now–2026  | RSA-2048 + AES-256-GCM | Current NIST   | Default                          |
| **Hybrid** | 2026–2027 | RSA + ML-DSA dual-sign | FIPS 204 draft | Government/enterprise clients    |
| **PQC**    | 2027+     | ML-DSA-65 only         | FIPS 204 final | Enterprise mandate or client SLA |

---
