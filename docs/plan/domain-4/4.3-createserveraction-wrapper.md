### 4.3 `createServerAction()` Wrapper

**What it is:** Every Server Action in this platform is wrapped with this function. It provides: input validation, authentication verification, tenant membership check (IDOR prevention), and error sanitization. It also directly mitigates the CVE-2025-29927 class by re-verifying auth inside the action, independent of middleware. [pentest-tools](https://pentest-tools.com/blog/cve-2025-29927-next-js-bypass)

**File:** `packages/auth/src/server-action-wrapper.ts`

```typescript
import { z, ZodSchema } from 'zod';
import { createServerClient } from '@supabase/ssr';
import { cookies, headers } from 'next/headers';
import { db } from '@repo/db';

// ============================================================================
// TYPES
// ============================================================================

export type ActionResult<T> =
  | { success: true; data: T }
  | { success: false; error: string; code: string };

export type ActionContext = {
  userId: string;
  tenantId: string;
  userRole: 'owner' | 'admin' | 'member' | 'viewer';
};

export type ActionHandler<TInput, TOutput> = (
  input: TInput,
  context: ActionContext
) => Promise<TOutput>;

// ============================================================================
// SANITIZE ERRORS (prevent leaking stack traces, SQL errors, internal paths)
// ============================================================================

function sanitizeError(error: unknown): { message: string; code: string } {
  // Never expose raw error messages to the client
  if (error instanceof z.ZodError) {
    return {
      message: 'Validation failed: ' + error.errors.map((e) => e.message).join(', '),
      code: 'VALIDATION_ERROR',
    };
  }

  // Detect RLS violations (Postgres error code 42501)
  if (
    error instanceof Error &&
    (error.message.includes('42501') || error.message.includes('row-level security'))
  ) {
    // Log for Sentry (see Domain 13) but return generic error to client
    console.error('[RLS Violation]', error);
    return { message: 'Access denied', code: 'RLS_VIOLATION' };
  }

  // Database connection errors
  if (error instanceof Error && error.message.includes('ECONNREFUSED')) {
    return { message: 'Service temporarily unavailable', code: 'DB_CONNECTION_ERROR' };
  }

  // Generic fallback — never expose raw error
  return { message: 'An unexpected error occurred', code: 'INTERNAL_ERROR' };
}

// ============================================================================
// VERIFY TENANT MEMBERSHIP (IDOR Prevention)
// Confirms the authenticated user is a member of the tenant they're acting on.
// This prevents Insecure Direct Object Reference (IDOR) attacks where a user
// from TenantA crafts a request targeting TenantB's data.
// ============================================================================

async function verifyTenantMembership(
  userId: string,
  tenantId: string
): Promise<{ role: ActionContext['userRole'] } | null> {
  const { data, error } = await db
    .from('tenant_members')
    .select('role')
    .eq('tenant_id', tenantId)
    .eq('user_id', userId)
    .single();

  if (error || !data) {
    return null;
  }

  return { role: data.role as ActionContext['userRole'] };
}

// ============================================================================
// MAIN WRAPPER
// Usage:
//   const submitLead = createServerAction(LeadSchema, async (input, ctx) => {
//     // input is type-safe and validated
//     // ctx.tenantId is verified (IDOR-safe)
//     // ctx.userId is from Supabase Auth (not user-controlled)
//     await db.from('leads').insert({ ...input, tenant_id: ctx.tenantId });
//   });
// ============================================================================

export function createServerAction<TInput, TOutput>(
  schema: ZodSchema<TInput>,
  handler: ActionHandler<TInput, TOutput>
) {
  return async (rawInput: unknown): Promise<ActionResult<TOutput>> => {
    try {
      // --- Step 1: Validate input with Zod BEFORE any auth check ---
      // This prevents processing malformed input that could cause unhandled exceptions
      const validationResult = schema.safeParse(rawInput);
      if (!validationResult.success) {
        return {
          success: false,
          error:
            'Validation failed: ' + validationResult.error.errors.map((e) => e.message).join(', '),
          code: 'VALIDATION_ERROR',
        };
      }
      const input = validationResult.data;

      // --- Step 2: Re-verify authentication INSIDE the action ---
      // CRITICAL: Do NOT rely solely on middleware for auth.
      // CVE-2025-29927 class vulnerabilities allow middleware bypass.
      // Auth must be verified independently in every Server Action.
      const cookieStore = await cookies();
      const supabase = createServerClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.SUPABASE_SERVICE_ROLE_KEY!, // Service role for server-side verification
        {
          cookies: {
            getAll() {
              return cookieStore.getAll();
            },
            setAll(cookiesToSet) {
              cookiesToSet.forEach(({ name, value, options }) => {
                cookieStore.set(name, value, options);
              });
            },
          },
        }
      );

      const {
        data: { user },
        error: authError,
      } = await supabase.auth.getUser();

      if (authError || !user) {
        return { success: false, error: 'Authentication required', code: 'UNAUTHENTICATED' };
      }

      // --- Step 3: Extract tenantId (from request headers — set by middleware) ---
      // IMPORTANT: We read tenantId from middleware headers, NOT from user input.
      // User-supplied tenantId would enable tenant spoofing attacks.
      const requestHeaders = await headers();
      const tenantId = requestHeaders.get('X-Tenant-Id');

      if (!tenantId) {
        return { success: false, error: 'Tenant context missing', code: 'MISSING_TENANT' };
      }

      // --- Step 4: Verify tenant membership (IDOR check) ---
      const membership = await verifyTenantMembership(user.id, tenantId);

      if (!membership) {
        // Log IDOR attempt for security monitoring
        console.error(`[IDOR Attempt] User ${user.id} attempted to access tenant ${tenantId}`);
        // Return 'access denied', not '404' — don't confirm tenant existence to attacker
        return { success: false, error: 'Access denied', code: 'IDOR_PREVENTED' };
      }

      // --- Step 5: Build context and execute handler ---
      const context: ActionContext = {
        userId: user.id,
        tenantId,
        userRole: membership.role,
      };

      const result = await handler(input, context);

      return { success: true, data: result };
    } catch (error) {
      // --- Step 6: Sanitize errors (never expose internals to client) ---
      const { message, code } = sanitizeError(error);
      return { success: false, error: message, code };
    }
  };
}

// ============================================================================
// ROLE-GATED VARIANT
// Usage:
//   const deleteClient = createServerAction(
//     DeleteClientSchema,
//     async (input, ctx) => { ... },
//     { requiredRoles: ['owner', 'admin'] }
//   );
// ============================================================================

export function createServerActionWithRole<TInput, TOutput>(
  schema: ZodSchema<TInput>,
  handler: ActionHandler<TInput, TOutput>,
  options: { requiredRoles: ActionContext['userRole'][] }
) {
  const baseAction = createServerAction(schema, async (input, context) => {
    if (!options.requiredRoles.includes(context.userRole)) {
      throw new Error(`Insufficient permissions. Required: ${options.requiredRoles.join(', ')}`);
    }
    return handler(input, context);
  });

  return baseAction;
}
```

**Usage example (a real Server Action):**

```typescript
// sites/sterling-law/src/features/contact-form/model/submit.ts
'use server';

import { z } from 'zod';
import { createServerAction } from '@repo/auth/server-action-wrapper';
import { db } from '@repo/db';
import { sendLeadNotification } from '@repo/email';
import { scoreLead } from '@repo/lead-capture';

const ContactFormSchema = z.object({
  name: z.string().min(2).max(100),
  email: z.string().email(),
  phone: z
    .string()
    .regex(/^\+?[1-9]\d{1,14}$/)
    .optional(),
  message: z.string().min(10).max(2000),
  utmSource: z.string().optional(),
  utmMedium: z.string().optional(),
  utmCampaign: z.string().optional(),
});

export const submitContactForm = createServerAction(ContactFormSchema, async (input, ctx) => {
  // ctx.tenantId is VERIFIED by the wrapper (IDOR-safe)
  // ctx.userId is from Supabase Auth (not user-controlled)

  const score = await scoreLead({
    tenantId: ctx.tenantId,
    eventType: 'formSubmission',
  });

  const { data: lead, error } = await db
    .from('leads')
    .insert({
      tenant_id: ctx.tenantId, // RLS also enforces this
      name: input.name,
      email: input.email,
      phone: input.phone ?? null,
      message: input.message,
      score,
      utm_source: input.utmSource ?? null,
      utm_medium: input.utmMedium ?? null,
      utm_campaign: input.utmCampaign ?? null,
      source: 'contact_form',
      status: score >= 50 ? 'qualified' : 'new',
    })
    .select('id')
    .single();

  if (error) throw error;

  await sendLeadNotification({ tenantId: ctx.tenantId, leadId: lead.id });

  return { leadId: lead.id };
});
```

---
