### 4.6 Post-Quantum Cryptography Abstraction

**File:** `packages/crypto/src/provider.ts`

```typescript
// ============================================================================
// CRYPTO PROVIDER INTERFACE (Algorithm-Agnostic)
// ============================================================================

export interface CryptoProvider {
  // Generate key pair
  generateKeyPair(): Promise<{
    publicKey: Uint8Array;
    privateKey: Uint8Array;
  }>;

  // Encrypt data with public key
  encrypt(Uint8Array, publicKey: Uint8Array): Promise<Uint8Array>;

  // Decrypt data with private key
  decrypt(ciphertext: Uint8Array, privateKey: Uint8Array): Promise<Uint8Array>;

  // Sign data with private key
  sign(Uint8Array, privateKey: Uint8Array): Promise<Uint8Array>;

  // Verify signature with public key
  verify(data: Uint8Array, signature: Uint8Array, publicKey: Uint8Array): Promise<boolean>;
}

// ============================================================================
// ALGORITHM CONFIG
// ============================================================================

export type CryptoAlgorithm = 'RSA-4096' | 'Hybrid-PQC' | 'ML-DSA';

export interface CryptoConfig {
  algorithm: CryptoAlgorithm;
  keySize?: number;
}

// ============================================================================
// FACTORY FUNCTION
// ============================================================================

export async function createCryptoProvider(config: CryptoConfig): Promise<CryptoProvider> {
  switch (config.algorithm) {
    case 'RSA-4096':
      const { RSAProvider } = await import('./rsa-provider');
      return new RSAProvider(config);

    case 'Hybrid-PQC':
      const { HybridProvider } = await import('./hybrid-provider');
      return new HybridProvider(config);

    case 'ML-DSA':
      const { MLDSAProvider } = await import('./ml-dsa-provider');
      return new MLDSAProvider(config);

    default:
      throw new Error(`Unsupported algorithm: ${config.algorithm}`);
  }
}
```

**Hybrid Provider (RSA + ML-KEM):**

**File:** `packages/crypto/src/hybrid-provider.ts`

```typescript
import { CryptoProvider, CryptoConfig } from './provider';

// ============================================================================
// HYBRID PROVIDER (RSA + ML-KEM-768)
// ============================================================================

export class HybridProvider implements CryptoProvider {
  private config: CryptoConfig;

  constructor(config: CryptoConfig) {
    this.config = config;
  }

  async generateKeyPair(): Promise<{
    publicKey: Uint8Array;
    privateKey: Uint8Array;
  }> {
    // Generate RSA-4096 key pair
    const rsaKeyPair = await crypto.subtle.generateKey(
      {
        name: 'RSA-OAEP',
        modulusLength: 4096,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: 'SHA-256',
      },
      true,
      ['encrypt', 'decrypt']
    );

    // Generate ML-KEM-768 key pair (post-quantum)
    // Note: Requires NIST PQC library (liboqs or similar)
    // This is a placeholder - actual implementation depends on library
    const mlkemKeyPair = await generateMLKEMKeyPair(); // Placeholder

    // Combine keys
    const publicKey = new Uint8Array([
      ...new Uint8Array(await crypto.subtle.exportKey('spki', rsaKeyPair.publicKey)),
      ...mlkemKeyPair.publicKey,
    ]);

    const privateKey = new Uint8Array([
      ...new Uint8Array(await crypto.subtle.exportKey('pkcs8', rsaKeyPair.privateKey)),
      ...mlkemKeyPair.privateKey,
    ]);

    return { publicKey, privateKey };
  }

  async encrypt(data: Uint8Array, publicKey: Uint8Array): Promise<Uint8Array> {
    // Hybrid encryption:
    // 1. Generate random symmetric key
    // 2. Encrypt data with AES-256-GCM (fast)
    // 3. Encrypt symmetric key with RSA-4096 (for backward compatibility)
    // 4. Encrypt symmetric key with ML-KEM-768 (for quantum resistance)

    // Generate symmetric key
    const symmetricKey = crypto.getRandomValues(new Uint8Array(32));

    // Encrypt data with AES-256-GCM
    const aesKey = await crypto.subtle.importKey(
      'raw',
      symmetricKey,
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt']
    );

    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encryptedData = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, aesKey, data);

    // Extract RSA and ML-KEM public keys
    const rsaPublicKey = await extractRSAPublicKey(publicKey);
    const mlkemPublicKey = extractMLKEMPublicKey(publicKey);

    // Encrypt symmetric key with RSA
    const rsaEncryptedKey = await crypto.subtle.encrypt(
      { name: 'RSA-OAEP' },
      rsaPublicKey,
      symmetricKey
    );

    // Encrypt symmetric key with ML-KEM
    const mlkemEncryptedKey = await encryptWithMLKEM(symmetricKey, mlkemPublicKey);

    // Combine ciphertext components
    return new Uint8Array([
      ...iv,
      ...new Uint8Array(rsaEncryptedKey),
      ...mlkemEncryptedKey,
      ...new Uint8Array(encryptedData),
    ]);
  }

  async decrypt(ciphertext: Uint8Array, privateKey: Uint8Array): Promise<Uint8Array> {
    // Hybrid decryption (reverse of encrypt)
    // Implementation details omitted for brevity
    throw new Error('Not implemented in this example');
  }

  async sign(Uint8Array, privateKey: Uint8Array): Promise<Uint8Array> {
    // Dual signature (RSA + ML-DSA for post-quantum)
    throw new Error('Not implemented in this example');
  }

  async verify(Uint8Array, signature: Uint8Array, publicKey: Uint8Array): Promise<boolean> {
    // Verify both RSA and ML-DSA signatures
    throw new Error('Not implemented in this example');
  }
}

// Placeholder functions (actual implementation uses liboqs or similar)
async function generateMLKEMKeyPair() {
  return {
    publicKey: new Uint8Array(1184), // ML-KEM-768 public key size
    privateKey: new Uint8Array(2400), // ML-KEM-768 private key size
  };
}

async function extractRSAPublicKey(publicKey: Uint8Array): Promise<CryptoKey> {
  // Extract RSA portion from combined key
  throw new Error('Not implemented');
}

function extractMLKEMPublicKey(publicKey: Uint8Array): Uint8Array {
  // Extract ML-KEM portion from combined key
  throw new Error('Not implemented');
}

async function encryptWithMLKEM(Uint8Array, publicKey: Uint8Array): Promise<Uint8Array> {
  // ML-KEM encapsulation
  throw new Error('Not implemented');
}
```

**Migration Timeline:**

**File:** `docs/architecture/pqc-timeline.md`

````markdown
# Post-Quantum Cryptography Migration Timeline

## Phase 1: RSA-4096 (Current)

**Timeline:** 2024‚Äì2026
**Algorithm:** RSA-4096 + SHA-256

**Status:** ‚úÖ Deployed

**Risk:** Vulnerable to quantum attacks (Shor's algorithm)

## Phase 2: Hybrid (RSA + ML-KEM)

**Timeline:** 2026‚Äì2028
**Algorithms:**

- Encryption: RSA-4096 + ML-KEM-768 (FIPS 203)
- Signatures: RSA-4096 + ML-DSA-65 (FIPS 204)

**Status:** üü° In Progress

**Benefits:**

- Backward compatibility (RSA)
- Quantum resistance (ML-KEM)
- Gradual migration path

**Implementation:**

- NIST finalized FIPS 203/204/205 in August 2024
- Libraries (liboqs, Bouncy Castle PQC) maturing in 2026

## Phase 3: Pure PQC (ML-DSA + ML-KEM)

**Timeline:** 2028‚Äì2030
**Algorithms:**

- Encryption: ML-KEM-768 only
- Signatures: ML-DSA-65 only

**Status:** üîµ Future

**Trigger:** NIST mandates PQC-only after quantum computers scale

**Migration Plan:**

1. Update `CryptoConfig` default to `ML-DSA`
2. Re-encrypt all tenant secrets with new keys
3. Update all client libraries
4. Deprecate RSA keys

## Algorithm Selection Criteria

| Criterion               | RSA-4096  | Hybrid      | ML-DSA      |
| ----------------------- | --------- | ----------- | ----------- |
| **Quantum Safe**        | ‚ùå        | ‚úÖ          | ‚úÖ          |
| **Backward Compatible** | ‚úÖ        | ‚úÖ          | ‚ùå          |
| **Key Size**            | 512 bytes | 2.5 KB      | 2 KB        |
| **Performance**         | Fast      | Medium      | Fast        |
| **NIST Approved**       | ‚úÖ        | ‚úÖ          | ‚úÖ          |
| **Library Support**     | Excellent | Good (2026) | Fair (2026) |

## Current Configuration

**File:** `packages/crypto/src/config.ts`

```typescript
export const CRYPTO_CONFIG: CryptoConfig = {
  algorithm:
    process.env.CRYPTO_ALGORITHM === 'ML-DSA'
      ? 'ML-DSA'
      : process.env.CRYPTO_ALGORITHM === 'Hybrid-PQC'
        ? 'Hybrid-PQC'
        : 'RSA-4096',
  keySize: 4096,
};
```
````

## Environment Variable

```bash
# .env (2026)
CRYPTO_ALGORITHM=Hybrid-PQC

# .env (2028)
CRYPTO_ALGORITHM=ML-DSA
```

```

**When to Build:** P2 (Not critical for 2026, but plan for 2027‚Äì2028)
```
