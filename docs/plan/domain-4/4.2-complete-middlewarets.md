### 4.2 Complete `middleware.ts`

**File:** `apps/*/src/middleware.ts` (or `sites/*/src/middleware.ts`)

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createServerClient } from '@supabase/ssr';
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';
import { resolveTenant } from '@repo/multi-tenant';
import { checkBillingStatus } from '@repo/multi-tenant';
import crypto from 'node:crypto';

// ============================================================================
// RATE LIMITING CONFIGURATION (Upstash Sliding Window)
// Per-tier limits enforce noisy-neighbor prevention (Domain 7 §7.5)
// ============================================================================

const redis = Redis.fromEnv();

const rateLimiters = {
  // Starter tier: 50 req/10s
  starter: new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(50, '10 s'),
    prefix: 'rl:starter',
    analytics: true,
  }),
  // Professional tier: 200 req/10s
  professional: new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(200, '10 s'),
    prefix: 'rl:professional',
    analytics: true,
  }),
  // Enterprise tier: 1000 req/10s
  enterprise: new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(1000, '10 s'),
    prefix: 'rl:enterprise',
    analytics: true,
  }),
  // Unauthenticated / bot traffic: 10 req/10s
  anonymous: new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(10, '10 s'),
    prefix: 'rl:anon',
    analytics: true,
  }),
};

// ============================================================================
// CSP NONCE GENERATION
// ============================================================================

function generateNonce(): string {
  return crypto.randomBytes(16).toString('base64');
}

function buildCSP(nonce: string): string {
  const directives = [
    `default-src 'self'`,
    `script-src 'self' 'nonce-${nonce}' 'strict-dynamic' https://www.googletagmanager.com https://www.google-analytics.com`,
    `style-src 'self' 'nonce-${nonce}' https://fonts.googleapis.com`,
    `font-src 'self' https://fonts.gstatic.com`,
    `img-src 'self' data: blob: https://cdn.supabase.io https://*.supabase.co https://images.unsplash.com`,
    `connect-src 'self' https://*.supabase.co wss://*.supabase.co https://www.google-analytics.com https://*.tinybird.co`,
    `frame-src 'self' https://calendly.com https://www.youtube.com`,
    `object-src 'none'`,
    `base-uri 'self'`,
    `form-action 'self'`,
    `upgrade-insecure-requests`,
    `block-all-mixed-content`,
  ];
  return directives.join('; ');
}

// ============================================================================
// SECURITY HEADERS
// ============================================================================

function applySecurityHeaders(
  response: NextResponse,
  nonce: string,
  tenantId?: string
): NextResponse {
  const csp = buildCSP(nonce);

  // Content Security Policy (nonce-based, defeats XSS)
  response.headers.set('Content-Security-Policy', csp);

  // Prevent clickjacking
  response.headers.set('X-Frame-Options', 'SAMEORIGIN');

  // Prevent MIME sniffing
  response.headers.set('X-Content-Type-Options', 'nosniff');

  // Referrer policy (privacy-preserving)
  response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin');

  // Permissions Policy (disable dangerous browser features)
  response.headers.set(
    'Permissions-Policy',
    'camera=(), microphone=(), geolocation=(self), payment=(self)'
  );

  // HSTS (1 year, include subdomains, preload)
  response.headers.set('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');

  // Cross-Origin policies (CORP/COEP/COOP for isolation)
  response.headers.set('Cross-Origin-Resource-Policy', 'same-origin');
  response.headers.set('Cross-Origin-Opener-Policy', 'same-origin');

  // Propagate nonce for use in components (via headers)
  response.headers.set('X-Nonce', nonce);

  // Propagate tenantId for downstream use
  if (tenantId) {
    response.headers.set('X-Tenant-Id', tenantId);
  }

  return response;
}

// ============================================================================
// CVE-2025-29927 MITIGATION
// Strip x-middleware-subrequest header from ALL incoming requests.
// This header was the attack vector for the Next.js middleware bypass.
// Even on Next.js 16 (patched), defense-in-depth dictates stripping it.
// Reference: https://securitylabs.datadoghq.com/articles/nextjs-middleware-auth-bypass/
// ============================================================================

function stripMiddlewareBypassHeaders(request: NextRequest): void {
  // These headers are internal to Next.js and must NEVER be set by external clients.
  // Stripping them here prevents the CVE-2025-29927 class of vulnerabilities.
  const dangerousHeaders = [
    'x-middleware-subrequest',
    'x-middleware-invoke',
    'x-invoke-path',
    'x-invoke-query',
    'x-invoke-output',
    'x-next-rewrite',
  ];

  dangerousHeaders.forEach((header) => {
    if (request.headers.has(header)) {
      // Log the attempt for security monitoring
      console.warn(`[Security] Blocked malicious header: ${header} from ${request.ip}`);
      request.headers.delete(header);
    }
  });
}

// ============================================================================
// PATHS THAT BYPASS MIDDLEWARE (public assets, health checks)
// ============================================================================

const PUBLIC_PATHS = [
  /^\/(_next|__nextjs|favicon\.ico|robots\.txt|sitemap\.xml|.*\.well-known)/,
  /^\/api\/webhooks\//, // Incoming webhooks (verify signatures internally)
  /^\/api\/health/, // Health check endpoints
];

function isPublicPath(pathname: string): boolean {
  return PUBLIC_PATHS.some((pattern) => pattern.test(pathname));
}

// ============================================================================
// MAIN MIDDLEWARE
// ============================================================================

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;

  // --- Step 1: Strip CVE-2025-29927 bypass headers (ALWAYS, before any logic) ---
  stripMiddlewareBypassHeaders(request);

  // --- Step 2: Generate CSP nonce for this request ---
  const nonce = generateNonce();

  // --- Step 3: Skip middleware for public paths ---
  if (isPublicPath(pathname)) {
    const response = NextResponse.next();
    return applySecurityHeaders(response, nonce);
  }

  // --- Step 4: Resolve tenant from request ---
  const tenantResolution = await resolveTenant(request);

  if (!tenantResolution.success) {
    // Unknown tenant — return 404, not 401 (don't leak tenant existence)
    return new NextResponse('Not Found', { status: 404 });
  }

  const { tenantId, tenantConfig } = tenantResolution;

  // --- Step 5: Check billing status (suspended tenants see graceful page) ---
  const billingStatus = await checkBillingStatus(tenantId);

  if (billingStatus === 'suspended') {
    // Rewrite to suspended page (not redirect — preserves URL, avoids SEO noise)
    const suspendedUrl = new URL('/suspended', request.url);
    const response = NextResponse.rewrite(suspendedUrl);
    return applySecurityHeaders(response, nonce, tenantId);
  }

  // --- Step 6: Rate limiting (per-tenant, per-tier) ---
  const tier = tenantConfig.billing?.tier ?? 'anonymous';
  const rateLimiter = rateLimiters[tier as keyof typeof rateLimiters] ?? rateLimiters.anonymous;

  // Key = tenantId + IP for finer granularity (prevents single IP monopoly)
  const identifier = `${tenantId}:${request.ip ?? 'unknown'}`;
  const { success: rateLimitPassed, limit, remaining, reset } = await rateLimiter.limit(identifier);

  if (!rateLimitPassed) {
    const response = new NextResponse('Too Many Requests', { status: 429 });
    response.headers.set('Retry-After', String(Math.ceil((reset - Date.now()) / 1000)));
    response.headers.set('X-RateLimit-Limit', String(limit));
    response.headers.set('X-RateLimit-Remaining', String(remaining));
    response.headers.set('X-RateLimit-Reset', String(reset));
    return applySecurityHeaders(response, nonce, tenantId);
  }

  // --- Step 7: Auth check (Supabase session) ---
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll();
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => {
            request.cookies.set(name, value);
            response = NextResponse.next({ request });
            response.cookies.set(name, value, options);
          });
        },
      },
    }
  );

  // Refresh session (extends expiry on each request)
  const {
    data: { user },
  } = await supabase.auth.getUser();

  // --- Step 8: Protect admin/portal routes ---
  const isAdminPath = pathname.startsWith('/admin');
  const isPortalPath = pathname.startsWith('/portal');

  if ((isAdminPath || isPortalPath) && !user) {
    const loginUrl = new URL('/auth/login', request.url);
    loginUrl.searchParams.set('callbackUrl', pathname);
    return NextResponse.redirect(loginUrl);
  }

  // --- Step 9: Propagate context to downstream (app routes, Server Actions) ---
  response.headers.set('X-Tenant-Id', tenantId);
  response.headers.set('X-Nonce', nonce);

  // Rate limit headers for debugging
  response.headers.set('X-RateLimit-Limit', String(limit));
  response.headers.set('X-RateLimit-Remaining', String(remaining));

  return applySecurityHeaders(response, nonce, tenantId);
}

export const config = {
  // Run middleware on all routes except static files and Next.js internals
  matcher: ['/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)'],
};
```

**Key security properties:**

- Header stripping runs **before** any other logic — CVE-2025-29927 class mitigated [securitylabs.datadoghq](https://securitylabs.datadoghq.com/articles/nextjs-middleware-auth-bypass/)
- CSP nonce generated per-request — defeats script injection attacks
- Tenant suspension checked via Redis (not DB) — low latency
- Rate limiting keyed `tenantId:IP` — noisy-neighbor prevention
- Auth session refresh on every request — detects revoked sessions [picussecurity](https://www.picussecurity.com/resource/blog/cve-2025-29927-nextjs-middleware-bypass-vulnerability)

---
