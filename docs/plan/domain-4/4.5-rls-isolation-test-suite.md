### 4.5 RLS Isolation Test Suite

**File:** `e2e/multi-tenant/rls-isolation.spec.ts`

```typescript
import { test, expect } from '@playwright/test';
import { createClient } from '@supabase/supabase-js';

// ============================================================================
// Test helpers: create isolated tenant users
// ============================================================================

async function setTenantContext(tenantId: string, role: 'owner' | 'member' = 'owner') {
  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );

  // Create a test user for this tenant
  const {
    data: { user },
  } = await supabase.auth.admin.createUser({
    email: `test-${tenantId}@test.example.com`,
    password: 'TestPassword123!',
    email_confirm: true,
  });

  if (!user) throw new Error('Failed to create test user');

  // Add user to tenant_members
  await supabase.from('tenant_members').insert({
    tenant_id: tenantId,
    user_id: user.id,
    role,
  });

  // Sign in as this user and return an authenticated client
  const {
    data: { session },
  } = await supabase.auth.signInWithPassword({
    email: `test-${tenantId}@test.example.com`,
    password: 'TestPassword123!',
  });

  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      global: {
        headers: {
          Authorization: `Bearer ${session!.access_token}`,
        },
      },
    }
  );
}

// Test tenant IDs (seeded in test DB)
const TENANT_A = '11111111-1111-1111-1111-111111111111';
const TENANT_B = '22222222-2222-2222-2222-222222222222';

test.describe('RLS Isolation: Cross-tenant data access is blocked', () => {
  test('Tenant A cannot read Tenant B leads', async () => {
    const clientA = await setTenantContext(TENANT_A);

    // Insert a lead for Tenant B using service role
    const adminClient = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    );

    const { data: seedLead } = await adminClient
      .from('leads')
      .insert({
        tenant_id: TENANT_B,
        name: 'Secret Lead',
        email: 'secret@tenantb.com',
        message: 'Confidential',
      })
      .select('id')
      .single();

    // Tenant A attempts to read Tenant B's lead — MUST return empty, not the lead
    const { data: leads, error } = await clientA.from('leads').select('*').eq('id', seedLead!.id);

    expect(error).toBeNull(); // No error — RLS silently filters, not errors
    expect(leads).toHaveLength(0); // CRITICAL: zero rows returned

    // Cleanup
    await adminClient.from('leads').delete().eq('id', seedLead!.id);
  });

  test('Tenant A cannot write leads into Tenant B', async () => {
    const clientA = await setTenantContext(TENANT_A);

    const { error } = await clientA.from('leads').insert({
      tenant_id: TENANT_B, // Attempting to inject into wrong tenant
      name: 'Malicious Lead',
      email: 'hacker@evil.com',
      message: 'IDOR attempt',
    });

    // RLS WITH CHECK should reject this insert
    expect(error).not.toBeNull();
    expect(error!.code).toBe('42501'); // Postgres RLS violation code
  });

  test('Tenant A cannot update Tenant B leads', async () => {
    const adminClient = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    );

    const { data: seedLead } = await adminClient
      .from('leads')
      .insert({
        tenant_id: TENANT_B,
        name: 'Original Name',
        email: 'original@tenantb.com',
        message: 'Original',
      })
      .select('id')
      .single();

    const clientA = await setTenantContext(TENANT_A);

    const { error } = await clientA
      .from('leads')
      .update({
        name: 'Hacked Name',
      })
      .eq('id', seedLead!.id);

    // RLS USING check should block this
    expect(error).not.toBeNull();

    // Verify data was not modified
    const { data: lead } = await adminClient
      .from('leads')
      .select('name')
      .eq('id', seedLead!.id)
      .single();

    expect(lead!.name).toBe('Original Name'); // Unchanged

    await adminClient.from('leads').delete().eq('id', seedLead!.id);
  });

  test('Tenant A cannot delete Tenant B bookings', async () => {
    const adminClient = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    );

    const { data: booking } = await adminClient
      .from('bookings')
      .insert({
        tenant_id: TENANT_B,
        name: 'Confidential Booking',
        email: 'client@tenantb.com',
        scheduled_at: new Date(Date.now() + 86400000).toISOString(),
      })
      .select('id')
      .single();

    const clientA = await setTenantContext(TENANT_A);

    const { error } = await clientA.from('bookings').delete().eq('id', booking!.id);

    // Should fail silently (0 rows deleted) or with RLS error
    const { data: stillExists } = await adminClient
      .from('bookings')
      .select('id')
      .eq('id', booking!.id)
      .single();

    expect(stillExists).not.toBeNull(); // Booking still exists

    await adminClient.from('bookings').delete().eq('id', booking!.id);
  });

  test('Audit logs are tenant-isolated', async () => {
    const clientA = await setTenantContext(TENANT_A);

    // Insert a lead for Tenant A (triggers audit log)
    await clientA.from('leads').insert({
      tenant_id: TENANT_A,
      name: 'Audited Lead',
      email: 'audited@tenanta.com',
      message: 'Test',
    });

    // Tenant A reads audit logs — should see only own logs
    const { data: logs } = await clientA.from('audit_logs').select('tenant_id');

    const wrongTenantLogs = logs?.filter((log) => log.tenant_id !== TENANT_A);
    expect(wrongTenantLogs).toHaveLength(0);
  });

  test('Server Action IDOR: submitContactForm rejects wrong tenantId', async () => {
    // This test submits a form with X-Tenant-Id set to TENANT_B
    // while the authenticated user belongs to TENANT_A
    // The createServerAction wrapper should reject this.
    // See Domain 4 §4.3 for the wrapper implementation.

    const response = await fetch('/api/test/server-action-idor', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Tenant-Id': TENANT_B, // Spoofed tenant header
        // Cookie: Authenticated as TENANT_A user (set by test setup)
      },
      body: JSON.stringify({
        name: 'Hacker',
        email: 'hacker@evil.com',
        message: 'IDOR test',
      }),
    });

    const result = await response.json();
    expect(result.success).toBe(false);
    expect(result.code).toBe('IDOR_PREVENTED');
  });
});
```

---

---

## Task Status

- **Task ID:** `DOMAIN-4-004`
- **Status:** ✅ Complete
- **Implementation references:** `packages/features/src/booking/lib/__tests__/multi-tenant-isolation.test.ts`
- **Focused QA:** `pnpm vitest run packages/features/src/booking/lib/__tests__/multi-tenant-isolation.test.ts`
