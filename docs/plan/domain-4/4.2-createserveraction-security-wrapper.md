### 4.2 createServerAction() Security Wrapper

**File:** `packages/server-actions/src/create-action.ts`

```typescript
import { z, ZodSchema } from 'zod';
import { headers } from 'next/headers';
import { createClient } from '@repo/database/client';

// ============================================================================
// ACTION CONTEXT (Injected into every action)
// ============================================================================

export interface ActionContext {
  userId: string | null;
  tenantId: string | null;
  userEmail: string | null;
  tenantRole: 'owner' | 'admin' | 'member' | null;
}

// ============================================================================
// ACTION OPTIONS
// ============================================================================

export interface ActionOptions<TInput, TOutput> {
  // Zod schema for input validation
  input?: ZodSchema<TInput>;

  // Require authenticated user
  requireAuth?: boolean;

  // Require tenant membership
  requireTenantMembership?: boolean;

  // Require specific tenant role
  requireRole?: 'owner' | 'admin' | 'member';

  // Custom authorization function
  authorize?: (context: ActionContext, input: TInput) => Promise<boolean>;
}

// ============================================================================
// ACTION RESULT (Success or Error)
// ============================================================================

export type ActionResult<TOutput> =
  | { success: true;  TOutput }
  | { success: false; error: string; code?: string };

// ============================================================================
// CREATE SERVER ACTION WRAPPER
// ============================================================================

export function createServerAction<TInput, TOutput>(
  handler: (input: TInput, context: ActionContext) => Promise<TOutput>,
  options: ActionOptions<TInput, TOutput> = {}
): (input: TInput) => Promise<ActionResult<TOutput>> {
  return async (input: TInput): Promise<ActionResult<TOutput>> => {
    try {
      // ========================================================================
      // STEP 1: PREVENT MIDDLEWARE BYPASS (CVE-2025-29927 class vulnerability)
      // ========================================================================

      const headersList = await headers();
      const middlewareSubrequest = headersList.get('x-middleware-subrequest');

      // If x-middleware-subrequest header is present, reject
      // (Legitimate requests should never have this header)
      if (middlewareSubrequest) {
        console.error('[SECURITY] Middleware bypass attempt detected');
        return {
          success: false,
          error: 'Unauthorized',
          code: 'MIDDLEWARE_BYPASS_DETECTED',
        };
      }

      // ========================================================================
      // STEP 2: INPUT VALIDATION
      // ========================================================================

      let validatedInput: TInput = input;

      if (options.input) {
        const result = options.input.safeParse(input);
        if (!result.success) {
          return {
            success: false,
            error: 'Invalid input',
            code: 'VALIDATION_ERROR',
          };
        }
        validatedInput = result.data;
      }

      // ========================================================================
      // STEP 3: AUTH VERIFICATION
      // ========================================================================

      const supabase = createClient();
      const {
         { user },
        error: authError,
      } = await supabase.auth.getUser();

      if (options.requireAuth && (!user || authError)) {
        return {
          success: false,
          error: 'Authentication required',
          code: 'UNAUTHENTICATED',
        };
      }

      // ========================================================================
      // STEP 4: TENANT MEMBERSHIP CHECK (IDOR Prevention)
      // ========================================================================

      const tenantSlug = headersList.get('x-tenant-slug');
      let context: ActionContext = {
        userId: user?.id || null,
        tenantId: null,
        userEmail: user?.email || null,
        tenantRole: null,
      };

      if (options.requireTenantMembership) {
        if (!user) {
          return {
            success: false,
            error: 'Authentication required',
            code: 'UNAUTHENTICATED',
          };
        }

        if (!tenantSlug) {
          return {
            success: false,
            error: 'Tenant context required',
            code: 'NO_TENANT_CONTEXT',
          };
        }

        // Check tenant membership
        const {  membership, error: membershipError } = await supabase
          .from('tenant_members')
          .select('tenant_id, role')
          .eq('user_id', user.id)
          .eq('tenant_slug', tenantSlug)
          .single();

        if (membershipError || !membership) {
          return {
            success: false,
            error: 'Access denied',
            code: 'NOT_TENANT_MEMBER',
          };
        }

        context.tenantId = membership.tenant_id;
        context.tenantRole = membership.role;

        // Check role requirement
        if (options.requireRole) {
          const roleHierarchy = { owner: 3, admin: 2, member: 1 };
          const userRoleLevel = roleHierarchy[membership.role];
          const requiredRoleLevel = roleHierarchy[options.requireRole];

          if (userRoleLevel < requiredRoleLevel) {
            return {
              success: false,
              error: 'Insufficient permissions',
              code: 'INSUFFICIENT_ROLE',
            };
          }
        }
      }

      // ========================================================================
      // STEP 5: CUSTOM AUTHORIZATION
      // ========================================================================

      if (options.authorize) {
        const authorized = await options.authorize(context, validatedInput);
        if (!authorized) {
          return {
            success: false,
            error: 'Access denied',
            code: 'AUTHORIZATION_FAILED',
          };
        }
      }

      // ========================================================================
      // STEP 6: EXECUTE HANDLER
      // ========================================================================

      const result = await handler(validatedInput, context);

      return {
        success: true,
         result,
      };
    } catch (error) {
      // ========================================================================
      // ERROR SANITIZATION (Prevent sensitive data leakage)
      // ========================================================================

      console.error('[ACTION ERROR]', error);

      // Don't expose internal error details to client
      return {
        success: false,
        error: 'An unexpected error occurred',
        code: 'INTERNAL_ERROR',
      };
    }
  };
}
```

**Usage Example:**

**File:** `apps/web/app/actions/leads.ts`

```typescript
'use server';

import { z } from 'zod';
import { createServerAction } from '@repo/server-actions';
import { createClient } from '@repo/database/client';

// Input validation schema
const CreateLeadSchema = z.object({
  name: z.string().min(1).max(100),
  email: z.string().email(),
  phone: z.string().optional(),
  message: z.string().max(1000).optional(),
  source: z.enum(['contact-form', 'phone-click', 'email-click']),
});

type CreateLeadInput = z.infer<typeof CreateLeadSchema>;

interface CreateLeadOutput {
  leadId: string;
  score: number;
}

export const createLead = createServerAction<CreateLeadInput, CreateLeadOutput>(
  async (input, context) => {
    // context.tenantId automatically injected and verified
    // input automatically validated via Zod

    const supabase = createClient();

    // Calculate lead score (simplified)
    const score = input.source === 'contact-form' ? 50 : 20;

    const { data, error } = await supabase
      .from('leads')
      .insert({
        tenant_id: context.tenantId, // âœ… IDOR prevention
        name: input.name,
        email: input.email,
        phone: input.phone,
        message: input.message,
        source: input.source,
        score,
        created_at: new Date().toISOString(),
      })
      .select('id, score')
      .single();

    if (error) {
      throw error;
    }

    return {
      leadId: data.id,
      score: data.score,
    };
  },
  {
    input: CreateLeadSchema,
    requireAuth: false, // Public form submission
    requireTenantMembership: false, // Tenant resolved from middleware
  }
);
```

**Why This Wrapper Matters:**

- CVE-2025-29927 mitigation: Detects and blocks middleware bypass attempts
- Input validation: Zod schemas prevent malformed data
- IDOR prevention: Verifies tenant membership before database operations
- Error sanitization: Prevents sensitive data leakage to client
- Consistent security: All actions follow same pattern (AI agents can't forget)

**When to Build:** P0 (Foundation for all server actions)
