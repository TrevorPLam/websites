### 4.5 Per-Tenant Secrets Management

**Encryption Helper:**

**File:** `packages/database/src/secrets.ts`

```typescript
import { createClient } from './client';

// ============================================================================
// ENCRYPT SECRET (pgcrypto)
// ============================================================================

export async function setTenantSecret(tenantId: string, key: string, value: string): Promise<void> {
  const supabase = createClient();

  // Use pgcrypto to encrypt value
  const { error } = await supabase.rpc('encrypt_tenant_secret', {
    p_tenant_id: tenantId,
    p_key: key,
    p_value: value,
  });

  if (error) {
    throw new Error(`Failed to set tenant secret: ${error.message}`);
  }
}

// ============================================================================
// DECRYPT SECRET (pgcrypto)
// ============================================================================

export async function getTenantSecret(tenantId: string, key: string): Promise<string | null> {
  const supabase = createClient();

  const { data, error } = await supabase.rpc('decrypt_tenant_secret', {
    p_tenant_id: tenantId,
    p_key: key,
  });

  if (error) {
    throw new Error(`Failed to get tenant secret: ${error.message}`);
  }

  return data as string | null;
}

// ============================================================================
// LIST SECRETS (Keys Only)
// ============================================================================

export async function listTenantSecretKeys(tenantId: string): Promise<string[]> {
  const supabase = createClient();

  const { data, error } = await supabase
    .from('tenant_secrets')
    .select('key')
    .eq('tenant_id', tenantId);

  if (error) {
    throw error;
  }

  return data.map((row) => row.key);
}
```

**PostgreSQL Functions (pgcrypto):**

**File:** `packages/database/src/migrations/003_secret_functions.sql`

```sql
-- Enable pgcrypto extension
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- ============================================================================
-- ENCRYPT TENANT SECRET FUNCTION
-- ============================================================================

CREATE OR REPLACE FUNCTION encrypt_tenant_secret(
  p_tenant_id UUID,
  p_key TEXT,
  p_value TEXT
) RETURNS VOID AS $$
DECLARE
  v_encrypted TEXT;
BEGIN
  -- Encrypt value using pgcrypto (AES-256)
  v_encrypted := encode(
    pgp_sym_encrypt(p_value, current_setting('app.secrets_key')),
    'base64'
  );

  -- Upsert encrypted value
  INSERT INTO tenant_secrets (tenant_id, key, value_encrypted, updated_at)
  VALUES (p_tenant_id, p_key, v_encrypted, NOW())
  ON CONFLICT (tenant_id, key)
  DO UPDATE SET
    value_encrypted = v_encrypted,
    updated_at = NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- DECRYPT TENANT SECRET FUNCTION
-- ============================================================================

CREATE OR REPLACE FUNCTION decrypt_tenant_secret(
  p_tenant_id UUID,
  p_key TEXT
) RETURNS TEXT AS $$
DECLARE
  v_encrypted TEXT;
  v_decrypted TEXT;
BEGIN
  -- Fetch encrypted value
  SELECT value_encrypted INTO v_encrypted
  FROM tenant_secrets
  WHERE tenant_id = p_tenant_id AND key = p_key;

  IF v_encrypted IS NULL THEN
    RETURN NULL;
  END IF;

  -- Decrypt value
  v_decrypted := pgp_sym_decrypt(
    decode(v_encrypted, 'base64'),
    current_setting('app.secrets_key')
  );

  RETURN v_decrypted;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- SET DATABASE SECRET KEY (Run once during setup)
-- ============================================================================

-- ALTER DATABASE postgres SET app.secrets_key = 'your-32-char-encryption-key';
-- (In production, use Supabase vault or environment variable)

-- Down: DROP FUNCTIONS
-- DROP FUNCTION encrypt_tenant_secret(UUID, TEXT, TEXT);
-- DROP FUNCTION decrypt_tenant_secret(UUID, TEXT);
```

**Secret Rotation Runbook:**

**File:** `docs/runbooks/secret-rotation.md`

````markdown
# Secret Rotation Runbook

## When to Rotate

- Every 90 days (scheduled)
- After employee offboarding
- After suspected compromise

## Rotation Steps

1. **Generate New Key**
   ```bash
   openssl rand -base64 32
   ```
````

2. **Update Database Setting**

   ```sql
   ALTER DATABASE postgres SET app.secrets_key = 'new-32-char-key';
   ```

3. **Re-encrypt All Secrets**

   ```bash
   pnpm --filter=@repo/database run rotate-secrets
   ```

4. **Verify Decryption**

   ```bash
   pnpm --filter=@repo/database run verify-secrets
   ```

5. **Update Environment Variables**
   - Update Vercel environment variables
   - Restart all deployments

## Rollback

If rotation fails:

```sql
ALTER DATABASE postgres SET app.secrets_key = 'old-32-char-key';
```

```

**When to Build:** P1 (After basic multi-tenancy works)
```
