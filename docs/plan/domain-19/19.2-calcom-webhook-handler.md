### 19.2 Cal.com Webhook Handler

**File:** `apps/*/src/app/api/webhooks/cal/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createHmac, timingSafeEqual } from 'crypto';
import { db } from '@repo/db';
import { enqueue } from '@repo/jobs/client';
import { classifyLead } from '@repo/lead-capture/scoring';

// ============================================================================
// CAL.COM WEBHOOK HANDLER (API v2)
// Events: BOOKING_CREATED, BOOKING_RESCHEDULED, BOOKING_CANCELLED,
//         BOOKING_CONFIRMED, BOOKING_COMPLETED, BOOKING_NO_SHOW
// Reference: https://cal.com/docs/api-reference/v2/event-types-webhooks
// ============================================================================

export const dynamic = 'force-dynamic';

// Idempotent signature verification (same pattern as Stripe)
function verifyCalWebhook(payload: string, signature: string | null, secret: string): boolean {
  if (!signature) return false;

  const expected = createHmac('sha256', secret).update(payload).digest('hex');

  try {
    return timingSafeEqual(Buffer.from(signature, 'hex'), Buffer.from(expected, 'hex'));
  } catch {
    return false;
  }
}

export async function POST(req: NextRequest) {
  const body = await req.text();
  const signature = req.headers.get('x-cal-signature-256');

  // Tenant ID is passed in the webhook URL: /api/webhooks/cal?tenant=abc123
  const tenantId = req.nextUrl.searchParams.get('tenant');
  if (!tenantId) {
    return NextResponse.json({ error: 'Missing tenant' }, { status: 400 });
  }

  // Fetch per-tenant Cal.com webhook secret from secrets manager
  const { getTenantSecret } = await import('@repo/security/secrets-manager');
  const webhookSecret = await getTenantSecret(tenantId, 'CAL_WEBHOOK_SECRET');

  if (!webhookSecret) {
    // Cal.com not configured for this tenant — silently accept (not an error)
    return NextResponse.json({ received: true });
  }

  if (!verifyCalWebhook(body, signature, webhookSecret)) {
    return NextResponse.json({ error: 'Invalid signature' }, { status: 401 });
  }

  // Idempotency: parse event ID from payload
  let event: CalWebhookEvent;
  try {
    event = JSON.parse(body);
  } catch {
    return NextResponse.json({ error: 'Invalid JSON' }, { status: 400 });
  }

  // Cal.com doesn't provide a unique event ID on the envelope —
  // construct one from booking UID + trigger type
  const eventId = `cal:${event.triggerEvent}:${event.payload?.uid}`;

  const { data: existing } = await db
    .from('processed_webhooks')
    .select('id')
    .eq('provider', 'cal')
    .eq('event_id', eventId)
    .maybeSingle();

  if (existing) {
    return NextResponse.json({ received: true, duplicate: true });
  }

  await db.from('processed_webhooks').insert({
    provider: 'cal',
    event_id: eventId,
    event_type: event.triggerEvent,
  });

  try {
    await handleCalEvent(event, tenantId);
    return NextResponse.json({ received: true });
  } catch (err) {
    console.error('[Cal.com Webhook] Handler error:', err);
    return NextResponse.json({ error: 'Handler failed' }, { status: 500 });
  }
}

// ============================================================================
// EVENT HANDLERS
// ============================================================================

async function handleCalEvent(event: CalWebhookEvent, tenantId: string): Promise<void> {
  switch (event.triggerEvent) {
    case 'BOOKING_CREATED':
      await handleBookingCreated(event.payload, tenantId);
      break;
    case 'BOOKING_RESCHEDULED':
      await handleBookingRescheduled(event.payload, tenantId);
      break;
    case 'BOOKING_CANCELLED':
      await handleBookingCancelled(event.payload, tenantId);
      break;
    case 'BOOKING_CONFIRMED':
      await handleBookingConfirmed(event.payload, tenantId);
      break;
    case 'BOOKING_COMPLETED':
      await handleBookingCompleted(event.payload, tenantId);
      break;
    case 'BOOKING_NO_SHOW':
      await handleBookingNoShow(event.payload, tenantId);
      break;
    default:
      console.log(`[Cal.com] Unhandled event: ${event.triggerEvent}`);
  }
}

async function handleBookingCreated(payload: CalBookingPayload, tenantId: string): Promise<void> {
  const attendee = payload.attendees?.[0];
  if (!attendee) return;

  // Upsert booking record
  const { data: booking, error } = await db
    .from('bookings')
    .upsert(
      {
        tenant_id: tenantId,
        cal_uid: payload.uid,
        cal_booking_id: payload.bookingId,
        status: 'confirmed',
        attendee_name: attendee.name,
        attendee_email: attendee.email,
        attendee_phone: attendee.phoneNumber ?? null,
        event_type: payload.type,
        event_title: payload.title,
        start_time: payload.startTime,
        end_time: payload.endTime,
        metadata: {
          responses: payload.responses,
          location: payload.location,
          organizer: payload.organizer,
          videoCallUrl: payload.videoCallUrl,
        },
        created_at: new Date().toISOString(),
      },
      { onConflict: 'cal_uid' }
    )
    .select()
    .single();

  if (error || !booking) {
    throw new Error(`Failed to upsert booking: ${error?.message}`);
  }

  // Auto-create or update lead from booking attendee (bookings = high-intent)
  const existingLead = await db
    .from('leads')
    .select('id, score')
    .eq('tenant_id', tenantId)
    .eq('email', attendee.email.toLowerCase())
    .maybeSingle();

  if (existingLead.data) {
    // Boost score: booking = +20 points
    const newScore = Math.min(100, (existingLead.data.score ?? 50) + 20);
    await db
      .from('leads')
      .update({
        score: newScore,
        status: 'booking_confirmed',
        updated_at: new Date().toISOString(),
      })
      .eq('id', existingLead.data.id);
  } else {
    // Create new lead from booking (score starts at 70 — bookings are qualified)
    const score = classifyLead({
      name: attendee.name,
      email: attendee.email,
      phone: attendee.phoneNumber ?? undefined,
      message: `Booking: ${payload.title} on ${new Date(payload.startTime).toLocaleDateString()}`,
      source: 'booking',
    });

    await db.from('leads').insert({
      tenant_id: tenantId,
      name: attendee.name,
      email: attendee.email.toLowerCase(),
      phone: attendee.phoneNumber ?? null,
      source: 'booking',
      status: 'booking_confirmed',
      score: Math.max(score, 70), // Bookings always start qualified
      booking_id: booking.id,
    });
  }

  // Schedule 24h reminder
  const bookingStart = new Date(payload.startTime);
  const reminder24h = new Date(bookingStart.getTime() - 24 * 60 * 60 * 1000);
  const now = new Date();

  if (reminder24h > now) {
    await enqueue(
      'booking.reminder',
      {
        tenantId,
        bookingId: booking.id,
        reminderType: '24h',
      },
      {
        notBefore: reminder24h,
        deduplicationId: `reminder-24h-${booking.id}`,
      }
    );
  }

  // Schedule 1h reminder
  const reminder1h = new Date(bookingStart.getTime() - 60 * 60 * 1000);
  if (reminder1h > now) {
    await enqueue(
      'booking.reminder',
      {
        tenantId,
        bookingId: booking.id,
        reminderType: '1h',
      },
      {
        notBefore: reminder1h,
        deduplicationId: `reminder-1h-${booking.id}`,
      }
    );
  }

  // Schedule post-appointment follow-up (+30 min after end)
  const followUpTime = new Date(new Date(payload.endTime).getTime() + 30 * 60 * 1000);
  await enqueue(
    'booking.followup',
    {
      tenantId,
      bookingId: booking.id,
    },
    {
      notBefore: followUpTime,
      deduplicationId: `followup-${booking.id}`,
    }
  );

  console.log(`[Cal.com] Booking created: ${booking.id} for tenant ${tenantId}`);
}

async function handleBookingRescheduled(
  payload: CalBookingPayload,
  tenantId: string
): Promise<void> {
  await db
    .from('bookings')
    .update({
      status: 'rescheduled',
      start_time: payload.startTime,
      end_time: payload.endTime,
      updated_at: new Date().toISOString(),
    })
    .eq('cal_uid', payload.uid)
    .eq('tenant_id', tenantId);

  // Re-queue reminders with new time (deduplication IDs are stable — QStash replaces)
  const bookingStart = new Date(payload.startTime);
  const reminder24h = new Date(bookingStart.getTime() - 24 * 60 * 60 * 1000);
  if (reminder24h > new Date()) {
    const { data: booking } = await db
      .from('bookings')
      .select('id')
      .eq('cal_uid', payload.uid)
      .single();

    if (booking) {
      await enqueue(
        'booking.reminder',
        {
          tenantId,
          bookingId: booking.id,
          reminderType: '24h',
        },
        {
          notBefore: reminder24h,
          deduplicationId: `reminder-24h-${booking.id}`,
        }
      );
    }
  }
}

async function handleBookingCancelled(payload: CalBookingPayload, tenantId: string): Promise<void> {
  await db
    .from('bookings')
    .update({
      status: 'cancelled',
      metadata: db.raw(
        `metadata || '{"cancellationReason": "${payload.cancellationReason ?? 'unspecified'}"}'::jsonb`
      ),
      updated_at: new Date().toISOString(),
    })
    .eq('cal_uid', payload.uid)
    .eq('tenant_id', tenantId);
}

async function handleBookingConfirmed(payload: CalBookingPayload, tenantId: string): Promise<void> {
  await db
    .from('bookings')
    .update({ status: 'confirmed', updated_at: new Date().toISOString() })
    .eq('cal_uid', payload.uid)
    .eq('tenant_id', tenantId);
}

async function handleBookingCompleted(payload: CalBookingPayload, tenantId: string): Promise<void> {
  await db
    .from('bookings')
    .update({ status: 'completed', updated_at: new Date().toISOString() })
    .eq('cal_uid', payload.uid)
    .eq('tenant_id', tenantId);

  // Update lead status to converted
  const { data: booking } = await db
    .from('bookings')
    .select('attendee_email')
    .eq('cal_uid', payload.uid)
    .single();

  if (booking) {
    await db
      .from('leads')
      .update({ status: 'converted', updated_at: new Date().toISOString() })
      .eq('tenant_id', tenantId)
      .eq('email', booking.attendee_email.toLowerCase());
  }
}

async function handleBookingNoShow(payload: CalBookingPayload, tenantId: string): Promise<void> {
  await db
    .from('bookings')
    .update({ status: 'no_show', updated_at: new Date().toISOString() })
    .eq('cal_uid', payload.uid)
    .eq('tenant_id', tenantId);
}

// ============================================================================
// CAL.COM API v2 TYPES
// ============================================================================

interface CalWebhookEvent {
  triggerEvent:
    | 'BOOKING_CREATED'
    | 'BOOKING_RESCHEDULED'
    | 'BOOKING_CANCELLED'
    | 'BOOKING_CONFIRMED'
    | 'BOOKING_COMPLETED'
    | 'BOOKING_NO_SHOW'
    | 'MEETING_STARTED'
    | 'MEETING_ENDED';
  createdAt: string;
  payload: CalBookingPayload;
}

interface CalBookingPayload {
  uid: string;
  bookingId: number;
  title: string;
  type: string;
  startTime: string;
  endTime: string;
  location: string;
  videoCallUrl?: string;
  cancellationReason?: string;
  responses?: Record<string, unknown>;
  organizer: { name: string; email: string; timeZone: string };
  attendees: Array<{ name: string; email: string; phoneNumber?: string; timeZone: string }>;
  metadata?: Record<string, unknown>;
}
```

---
