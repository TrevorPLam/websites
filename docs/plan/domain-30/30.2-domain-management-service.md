### 30.2 Domain Management Service

**File:** `packages/domains/src/vercel-domains.ts`

```typescript
import { Redis } from '@upstash/redis';
import { db } from '@repo/db';

const redis = Redis.fromEnv();

const VERCEL_API = 'https://api.vercel.com';
const VERCEL_TOKEN = process.env.VERCEL_API_TOKEN!;
const VERCEL_TEAM_ID = process.env.VERCEL_TEAM_ID!;
const VERCEL_PROJECT_ID = process.env.VERCEL_PROJECT_ID!;

// ============================================================================
// VERCEL DOMAINS API WRAPPER
// Reference: https://vercel.com/docs/multi-tenant/domain-management
// ============================================================================

interface VercelDomainResponse {
  name: string;
  apexName: string;
  projectId: string;
  redirect?: string;
  verified: boolean;
  verification?: VercelVerificationChallenge[];
}

interface VercelVerificationChallenge {
  type: 'TXT';
  domain: string;
  value: string;
  reason: string;
}

interface DomainAddResult {
  status: 'added' | 'already_exists' | 'conflict' | 'error';
  domain?: VercelDomainResponse;
  dnsInstructions?: DNSInstruction[];
  error?: string;
}

interface DNSInstruction {
  type: 'A' | 'CNAME' | 'TXT';
  name: string; // '@' or 'www'
  value: string;
  ttl?: number;
  note?: string;
}

export async function addDomainToVercel(domain: string): Promise<DomainAddResult> {
  const response = await fetch(
    `${VERCEL_API}/v9/projects/${VERCEL_PROJECT_ID}/domains?teamId=${VERCEL_TEAM_ID}`,
    {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${VERCEL_TOKEN}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ name: domain }),
    }
  );

  if (response.status === 409) {
    // Domain already exists in this project
    return { status: 'already_exists' };
  }

  if (response.status === 403) {
    // Domain belongs to another Vercel team
    return {
      status: 'conflict',
      error:
        'This domain is currently associated with another project. Please remove it from its current location first.',
    };
  }

  if (!response.ok) {
    const error = await response.text();
    return { status: 'error', error };
  }

  const data: VercelDomainResponse = await response.json();

  // Build DNS instructions based on whether it's apex or subdomain
  const isApex = !domain.includes('.', domain.indexOf('.') + 1) || domain.split('.').length === 2;

  const dnsInstructions: DNSInstruction[] = isApex
    ? [
        {
          type: 'A',
          name: '@',
          value: '76.76.21.21',
          ttl: 3600,
          note: 'Add at your DNS provider for the root domain',
        },
        {
          type: 'CNAME',
          name: 'www',
          value: 'cname.vercel-dns.com.',
          ttl: 3600,
          note: 'Optional: redirects www to root domain',
        },
      ]
    : [
        {
          type: 'CNAME',
          name: domain.split('.')[0],
          value: 'cname.vercel-dns.com.',
          ttl: 3600,
          note: 'Add at your DNS provider',
        },
      ];

  // If Vercel requires a verification TXT record (domain in use elsewhere)
  if (data.verification?.length) {
    data.verification.forEach((v) => {
      dnsInstructions.push({
        type: 'TXT',
        name: v.domain.replace(`.${domain}`, '') || '@',
        value: v.value,
        note: 'Required for domain verification: ' + v.reason,
      });
    });
  }

  return { status: 'added', domain: data, dnsInstructions };
}

export async function removeDomainFromVercel(domain: string): Promise<void> {
  await fetch(
    `${VERCEL_API}/v9/projects/${VERCEL_PROJECT_ID}/domains/${domain}?teamId=${VERCEL_TEAM_ID}`,
    {
      method: 'DELETE',
      headers: { Authorization: `Bearer ${VERCEL_TOKEN}` },
    }
  );
}

export async function checkDomainVerification(
  domain: string
): Promise<{ verified: boolean; config?: VercelDomainResponse }> {
  const response = await fetch(
    `${VERCEL_API}/v9/projects/${VERCEL_PROJECT_ID}/domains/${domain}?teamId=${VERCEL_TEAM_ID}`,
    {
      headers: { Authorization: `Bearer ${VERCEL_TOKEN}` },
    }
  );

  if (!response.ok) return { verified: false };

  const data: VercelDomainResponse = await response.json();

  return { verified: data.verified, config: data };
}

// ============================================================================
// TENANT DOMAIN MANAGEMENT
// ============================================================================

export async function addCustomDomainForTenant(
  tenantId: string,
  domain: string
): Promise<DomainAddResult> {
  // Normalize: lowercase, strip protocol, strip trailing slash
  const normalized = domain
    .toLowerCase()
    .replace(/^https?:\/\//, '')
    .replace(/\/+$/, '');

  // Check if domain is already claimed by another tenant
  const { data: existing } = await db
    .from('tenants')
    .select('id')
    .eq('custom_domain', normalized)
    .neq('id', tenantId)
    .maybeSingle();

  if (existing) {
    return {
      status: 'conflict',
      error: 'This domain is already registered to another account.',
    };
  }

  // Add to Vercel
  const result = await addDomainToVercel(normalized);

  if (result.status === 'added' || result.status === 'already_exists') {
    // Save domain (unverified) to tenant record
    await db
      .from('tenants')
      .update({
        custom_domain: normalized,
        custom_domain_verified: false,
        custom_domain_added_at: new Date().toISOString(),
      })
      .eq('id', tenantId);

    // Store DNS instructions in Redis (TTL 7 days — client needs time to update DNS)
    if (result.dnsInstructions) {
      await redis.setex(
        `domain-dns:${tenantId}`,
        7 * 24 * 3600,
        JSON.stringify(result.dnsInstructions)
      );
    }

    // Schedule first verification check in 5 minutes
    const { enqueue } = await import('@repo/jobs/client');
    await enqueue(
      'domain.verify',
      { tenantId, domain: normalized },
      {
        notBefore: new Date(Date.now() + 5 * 60 * 1000),
      }
    );
  }

  return result;
}

export async function verifyAndActivateDomain(
  tenantId: string,
  domain: string
): Promise<{ activated: boolean; retryIn?: number }> {
  const { verified } = await checkDomainVerification(domain);

  if (verified) {
    await db
      .from('tenants')
      .update({
        custom_domain_verified: true,
        custom_domain_verified_at: new Date().toISOString(),
      })
      .eq('id', tenantId);

    // Bust cache so middleware picks up new domain
    await redis.del(`tenant-domain:${domain}`);

    // Also provision Resend sending domain (now that custom domain is verified)
    const { checkTenantEmailDomainVerification } = await import('@repo/email/client');
    await checkTenantEmailDomainVerification(tenantId);

    return { activated: true };
  }

  // Not yet verified — schedule retry with exponential backoff
  // (5min, 10min, 20min, 1h, 2h, 6h, 12h, 24h)
  return { activated: false, retryIn: 300 };
}

export async function removeCustomDomainForTenant(tenantId: string): Promise<void> {
  const { data: tenant } = await db
    .from('tenants')
    .select('custom_domain')
    .eq('id', tenantId)
    .single();

  if (!tenant?.custom_domain) return;

  await removeDomainFromVercel(tenant.custom_domain);

  await db
    .from('tenants')
    .update({
      custom_domain: null,
      custom_domain_verified: false,
      custom_domain_added_at: null,
      custom_domain_verified_at: null,
    })
    .eq('id', tenantId);

  await redis.del(`tenant-domain:${tenant.custom_domain}`);
  await redis.del(`domain-dns:${tenantId}`);
}
```

---
