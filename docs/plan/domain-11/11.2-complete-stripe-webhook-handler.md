### 11.2 Complete Stripe Webhook Handler

**File:** `apps/*/src/app/api/webhooks/stripe/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server';
import Stripe from 'stripe';
import { db } from '@repo/db';
import { updateBillingStatus } from '@repo/multi-tenant/check-billing';
import { invalidateTenantCache } from '@repo/multi-tenant/resolve-tenant';
import { sendBillingEmail } from '@repo/email';
import { Client as QStashClient } from '@upstash/qstash';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2025-11-27.acacia',
});

const qstash = new QStashClient({ token: process.env.QSTASH_TOKEN! });

// ============================================================================
// WEBHOOK ROUTE
// Edge Runtime: lowest cold-start latency for time-sensitive billing events
// Must verify Stripe signature BEFORE reading body
// ============================================================================

export const runtime = 'nodejs'; // Stripe SDK requires Node.js (crypto.createHmac)
export const dynamic = 'force-dynamic';

export async function POST(req: NextRequest) {
  let event: Stripe.Event;

  // ── Step 1: Signature verification (MUST be first — before any parsing) ──
  const body = await req.text(); // Raw body required for signature validation
  const signature = req.headers.get('stripe-signature');

  if (!signature) {
    return NextResponse.json({ error: 'Missing signature' }, { status: 400 });
  }

  try {
    event = stripe.webhooks.constructEvent(body, signature, process.env.STRIPE_WEBHOOK_SECRET!);
  } catch (err) {
    console.error('[Stripe Webhook] Signature verification failed:', err);
    return NextResponse.json({ error: 'Invalid signature' }, { status: 400 });
  }

  // ── Step 2: Idempotency check (prevents double-processing) ────────────────
  // Store event in DB first — if already exists, return 200 immediately
  const { data: existing, error: checkError } = await db
    .from('processed_webhooks')
    .select('id')
    .eq('provider', 'stripe')
    .eq('event_id', event.id)
    .maybeSingle();

  if (existing) {
    // Already processed — return 200 so Stripe stops retrying
    console.log(`[Stripe Webhook] Duplicate event skipped: ${event.id}`);
    return NextResponse.json({ received: true, duplicate: true });
  }

  // Insert idempotency record (will fail with unique constraint if race condition)
  const { error: insertError } = await db.from('processed_webhooks').insert({
    provider: 'stripe',
    event_id: event.id,
    event_type: event.type,
  });

  if (insertError) {
    // Another instance beat us to it — safe to ignore
    if (insertError.code === '23505') {
      return NextResponse.json({ received: true, duplicate: true });
    }
    console.error('[Stripe Webhook] Failed to record event:', insertError);
    return NextResponse.json({ error: 'DB error' }, { status: 500 });
  }

  // ── Step 3: Route to handler ──────────────────────────────────────────────
  try {
    await handleStripeEvent(event);
    return NextResponse.json({ received: true });
  } catch (err) {
    // On handler failure: mark webhook as failed for retry
    console.error(`[Stripe Webhook] Handler failed for ${event.type}:`, err);
    // Return 500 — Stripe will retry
    return NextResponse.json({ error: 'Handler failed' }, { status: 500 });
  }
}

// ============================================================================
// EVENT HANDLERS
// ============================================================================

async function handleStripeEvent(event: Stripe.Event): Promise<void> {
  switch (event.type) {
    // ── Subscription lifecycle ──────────────────────────────────────────────

    case 'customer.subscription.created':
      await handleSubscriptionCreated(event.data.object as Stripe.Subscription);
      break;

    case 'customer.subscription.updated':
      await handleSubscriptionUpdated(event.data.object as Stripe.Subscription);
      break;

    case 'customer.subscription.deleted':
      await handleSubscriptionCancelled(event.data.object as Stripe.Subscription);
      break;

    // ── Payment lifecycle ───────────────────────────────────────────────────

    case 'invoice.payment_succeeded':
      await handlePaymentSucceeded(event.data.object as Stripe.Invoice);
      break;

    case 'invoice.payment_failed':
      await handlePaymentFailed(event.data.object as Stripe.Invoice);
      break;

    case 'invoice.upcoming':
      // Pre-billing notice — send reminder email
      await handleUpcomingInvoice(event.data.object as Stripe.Invoice);
      break;

    // ── Customer portal ─────────────────────────────────────────────────────

    case 'billing_portal.session.created':
      // No-op (audit log only)
      console.log('[Stripe] Customer portal session created');
      break;

    // ── Checkout ────────────────────────────────────────────────────────────

    case 'checkout.session.completed':
      await handleCheckoutCompleted(event.data.object as Stripe.Checkout.Session);
      break;

    default:
      // Log unhandled events (useful for discovering new events to handle)
      console.log(`[Stripe Webhook] Unhandled event type: ${event.type}`);
  }
}

// ──────────────────────────────────────────────────────────────────────────────

async function getTenantByStripeCustomer(customerId: string): Promise<string | null> {
  const { data: tenant } = await db
    .from('tenants')
    .select('id')
    .eq('stripe_customer_id', customerId)
    .single();
  return tenant?.id ?? null;
}

// ──────────────────────────────────────────────────────────────────────────────

async function handleSubscriptionCreated(sub: Stripe.Subscription): Promise<void> {
  const tenantId = await getTenantByStripeCustomer(sub.customer as string);
  if (!tenantId) return;

  const tier = mapPriceToTier(sub.items.data[0]?.price.id ?? '');

  await db
    .from('tenants')
    .update({
      stripe_subscription_id: sub.id,
      status: 'active',
      billing_tier: tier,
      updated_at: new Date().toISOString(),
    })
    .eq('id', tenantId);

  await updateBillingStatus(tenantId, 'active');
  await invalidateTenantCache(tenantId);

  console.log(`[Stripe] Subscription created: tenant=${tenantId}, tier=${tier}`);
}

async function handleSubscriptionUpdated(sub: Stripe.Subscription): Promise<void> {
  const tenantId = await getTenantByStripeCustomer(sub.customer as string);
  if (!tenantId) return;

  const tier = mapPriceToTier(sub.items.data[0]?.price.id ?? '');

  // Stripe subscription status: active, past_due, canceled, unpaid, trialing
  const platformStatus = mapStripeStatusToPlatform(sub.status);

  await db
    .from('tenants')
    .update({
      status: platformStatus,
      billing_tier: tier,
      updated_at: new Date().toISOString(),
    })
    .eq('id', tenantId);

  await updateBillingStatus(tenantId, platformStatus);
  await invalidateTenantCache(tenantId);

  // Notify client of plan change
  if (platformStatus === 'active') {
    await sendBillingEmail('plan_changed', tenantId, { newTier: tier });
  }
}

async function handleSubscriptionCancelled(sub: Stripe.Subscription): Promise<void> {
  const tenantId = await getTenantByStripeCustomer(sub.customer as string);
  if (!tenantId) return;

  await updateBillingStatus(tenantId, 'cancelled');
  await invalidateTenantCache(tenantId);

  // Queue 30-day grace period deletion (GDPR data retention)
  await qstash.publishJSON({
    url: `${process.env.NEXT_PUBLIC_APP_URL}/api/internal/offboarding/queue`,
    body: {
      tenantId,
      reason: 'billing_lapse',
    },
    delay: 60 * 60 * 24 * 30, // 30 days
    retries: 3,
  });

  await sendBillingEmail('subscription_cancelled', tenantId, {
    cancelledAt: new Date(sub.canceled_at! * 1000).toISOString(),
  });

  console.log(`[Stripe] Subscription cancelled: tenant=${tenantId}`);
}

async function handlePaymentSucceeded(invoice: Stripe.Invoice): Promise<void> {
  if (!invoice.subscription) return; // Skip one-time payments

  const tenantId = await getTenantByStripeCustomer(invoice.customer as string);
  if (!tenantId) return;

  // Ensure status is active (payment failure might have suspended them)
  await updateBillingStatus(tenantId, 'active');
  await invalidateTenantCache(tenantId);

  // Send receipt email via QStash (async — don't block webhook response)
  await qstash.publishJSON({
    url: `${process.env.NEXT_PUBLIC_APP_URL}/api/internal/email/billing-receipt`,
    body: {
      tenantId,
      invoiceId: invoice.id,
      amountPaid: invoice.amount_paid,
      currency: invoice.currency,
      hostedInvoiceUrl: invoice.hosted_invoice_url,
    },
  });
}

async function handlePaymentFailed(invoice: Stripe.Invoice): Promise<void> {
  if (!invoice.subscription) return;

  const tenantId = await getTenantByStripeCustomer(invoice.customer as string);
  if (!tenantId) return;

  const attemptCount = invoice.attempt_count ?? 1;

  // Graduated response to payment failure:
  // Attempt 1: warning email, stay active
  // Attempt 2: warning + payment method prompt, stay active
  // Attempt 3+: suspend access
  if (attemptCount >= 3) {
    await updateBillingStatus(tenantId, 'suspended');
    await invalidateTenantCache(tenantId);
    await sendBillingEmail('account_suspended', tenantId, { attemptCount });
  } else {
    await sendBillingEmail('payment_failed', tenantId, {
      attemptCount,
      nextAttempt: invoice.next_payment_attempt
        ? new Date(invoice.next_payment_attempt * 1000).toISOString()
        : null,
    });
  }
}

async function handleUpcomingInvoice(invoice: Stripe.Invoice): Promise<void> {
  const tenantId = await getTenantByStripeCustomer(invoice.customer as string);
  if (!tenantId) return;

  await sendBillingEmail('upcoming_invoice', tenantId, {
    amount: invoice.amount_due,
    currency: invoice.currency,
    dueDate: new Date((invoice.due_date ?? invoice.created) * 1000).toISOString(),
  });
}

async function handleCheckoutCompleted(session: Stripe.Checkout.Session): Promise<void> {
  if (!session.customer || !session.subscription) return;

  const tenantId = session.metadata?.tenantId;
  if (!tenantId) return;

  // Link Stripe customer to tenant (first subscription)
  await db
    .from('tenants')
    .update({
      stripe_customer_id: session.customer as string,
      stripe_subscription_id: session.subscription as string,
      status: 'active',
      updated_at: new Date().toISOString(),
    })
    .eq('id', tenantId);

  await updateBillingStatus(tenantId, 'active');
  await invalidateTenantCache(tenantId);

  await sendBillingEmail('subscription_started', tenantId, {});
}

// ============================================================================
// HELPERS
// ============================================================================

const PRICE_TIER_MAP: Record<string, 'starter' | 'professional' | 'enterprise'> = {
  [process.env.STRIPE_STARTER_PRICE_ID!]: 'starter',
  [process.env.STRIPE_PROFESSIONAL_PRICE_ID!]: 'professional',
  [process.env.STRIPE_ENTERPRISE_PRICE_ID!]: 'enterprise',
};

function mapPriceToTier(priceId: string): 'starter' | 'professional' | 'enterprise' {
  return PRICE_TIER_MAP[priceId] ?? 'starter';
}

function mapStripeStatusToPlatform(
  stripeStatus: Stripe.Subscription.Status
): 'active' | 'trial' | 'suspended' | 'cancelled' {
  const map: Record<string, 'active' | 'trial' | 'suspended' | 'cancelled'> = {
    active: 'active',
    trialing: 'trial',
    past_due: 'suspended', // After first missed payment
    unpaid: 'suspended',
    canceled: 'cancelled',
    incomplete: 'suspended',
    incomplete_expired: 'cancelled',
    paused: 'suspended',
  };
  return map[stripeStatus] ?? 'suspended';
}
```

---
