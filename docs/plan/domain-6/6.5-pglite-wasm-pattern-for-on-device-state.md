### 6.5 PGlite WASM Pattern for On-Device State

**What it is:** PGlite is a 3MB WASM Postgres build that runs entirely in the browser. Unlike ElectricSQL (sync-first), PGlite alone is pure local Postgres — no server required. Best for complex client-side state that benefits from SQL queries but doesn't need server sync. [github](https://github.com/electric-sql/pglite)

**Use cases for marketing platform:**

- Admin dashboard filters and aggregations (instant, no round-trips)
- Client portal lead search with full-text SQL
- Session-local A/B test state management

```typescript
// packages/analytics/src/pglite-session-store.ts
'use client';

import { PGlite } from '@electric-sql/pglite';

// In-memory only (no IndexedDB persistence) — session-local state
let _sessionDb: PGlite | null = null;

async function getSessionDb(): Promise<PGlite> {
  if (_sessionDb) return _sessionDb;

  // 'memory://' = in-memory, no persistence between page loads
  _sessionDb = new PGlite('memory://');

  await _sessionDb.exec(`
    CREATE TABLE IF NOT EXISTS page_views (
      id          SERIAL PRIMARY KEY,
      pathname    TEXT NOT NULL,
      viewed_at   TIMESTAMPTZ NOT NULL DEFAULT now()
    );

    CREATE TABLE IF NOT EXISTS events (
      id          SERIAL PRIMARY KEY,
      type        TEXT NOT NULL,
      payload     JSONB,
      occurred_at TIMESTAMPTZ NOT NULL DEFAULT now()
    );
  `);

  return _sessionDb;
}

export async function recordPageView(pathname: string): Promise<void> {
  const db = await getSessionDb();
  await db.query('INSERT INTO page_views (pathname) VALUES ($1)', [pathname]);
}

export async function recordEvent(type: string, payload?: Record<string, unknown>): Promise<void> {
  const db = await getSessionDb();
  await db.query('INSERT INTO events (type, payload) VALUES ($1, $2)', [
    type,
    payload ? JSON.stringify(payload) : null,
  ]);
}

export async function getSessionScore(): Promise<number> {
  const db = await getSessionDb();

  const { rows: viewRows } = await db.query<{ count: string }>(
    'SELECT COUNT(*) as count FROM page_views'
  );
  const pageViews = Number(viewRows[0]?.count ?? 0);

  const { rows: eventRows } = await db.query<{ type: string; count: string }>(
    `SELECT type, COUNT(*) as count FROM events GROUP BY type`
  );

  // Score calculation using session data
  let score = 0;
  if (pageViews >= 3) score += 10;
  if (pageViews >= 5) score += 10;

  for (const row of eventRows) {
    if (row.type === 'phone_click') score += 30;
    if (row.type === 'form_start') score += 15;
    if (row.type === 'booking_click') score += 25;
  }

  return Math.min(score, 100);
}
```

---
