### 6.2 Connection Pooling Configuration

Supabase provides **Supavisor** (the recommended pooler replacing PgBouncer) built into all plans.

**File:** `packages/db/src/client.ts`

```typescript
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { createServerClient as createSSRClient } from '@supabase/ssr';
import type { Database } from './types';

// ============================================================================
// SINGLETON CLIENT (prevents connection explosion in serverless)
// ============================================================================

let _adminClient: SupabaseClient<Database> | null = null;

export function getAdminClient(): SupabaseClient<Database> {
  if (_adminClient) return _adminClient;

  _adminClient = createClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      db: {
        schema: 'public',
      },
      auth: {
        persistSession: false, // Server-side: no session persistence
        autoRefreshToken: false,
        detectSessionInUrl: false,
      },
      // Use Transaction mode pooler URL (Supavisor)
      // Format: postgresql://postgres.[project-ref]:password@aws-0-us-east-1.pooler.supabase.com:6543/postgres
    }
  );

  return _adminClient;
}

// Shorthand for Server Components and Server Actions
export const db = getAdminClient();

// ============================================================================
// SERVER-SIDE CLIENT (per-request, honors RLS via user JWT)
// Called in Server Components and Server Actions that need RLS
// ============================================================================

export async function createRLSClient() {
  const { cookies } = await import('next/headers');
  const cookieStore = await cookies();

  return createSSRClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => {
            cookieStore.set(name, value, options);
          });
        },
      },
    }
  );
}

// ============================================================================
// READ REPLICA ROUTING (for analytics queries)
// Supabase supports read replicas on Enterprise plan.
// Route heavy analytics queries to replica to protect primary.
// ============================================================================

let _replicaClient: SupabaseClient<Database> | null = null;

export function getReplicaClient(): SupabaseClient<Database> {
  // Fall back to primary if no replica configured
  if (!process.env.SUPABASE_REPLICA_URL) {
    return getAdminClient();
  }

  if (_replicaClient) return _replicaClient;

  _replicaClient = createClient<Database>(
    process.env.SUPABASE_REPLICA_URL,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      auth: {
        persistSession: false,
        autoRefreshToken: false,
      },
    }
  );

  return _replicaClient;
}

// Use this for analytics queries (Core Web Vitals dashboard, lead reports)
export const replicaDb = getReplicaClient();
```

**PgBouncer/Supavisor multi-tenant configuration:** [oneuptime](https://oneuptime.com/blog/post/2026-02-02-postgresql-pgbouncer-pooling/view)

```ini
# supavisor.toml (Supabase handles this — provided for self-hosted setups)
[pgbouncer]
# Transaction mode: connection returned to pool after each transaction
# Required for serverless (functions don't maintain persistent connections)
pool_mode = transaction

# Connection limits
max_client_conn = 5000           # Total client connections accepted
default_pool_size = 20           # Connections per user/database pair
min_pool_size = 2                # Keep minimum alive for low-latency
reserve

---

Excellent — I now have all the research needed to complete Domains 6 and 7 at full depth. Here is the continuation.

***
```
