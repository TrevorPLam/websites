### 6.4 ElectricSQL Local-First Sync Pattern

**What it is:** ElectricSQL syncs shapes (subsets of Postgres tables) to local PGlite WASM instances in the browser. For marketing sites, the primary use case is **offline-capable contact forms** and **cached service listings** — users fill out the form even if they lose connectivity, and it syncs to Postgres when the connection restores. [blog.logrocket](https://blog.logrocket.com/using-electricsql-build-local-first-app/)

**When to use:**

- Offline-capable lead capture forms (home services clients — contractors have spotty connectivity)
- Real-time multi-user booking calendars
- Dashboards that need instant local reactivity

**File:** `packages/ui/src/marketing/offline-lead-form/OfflineLeadForm.tsx`

```typescript
'use client';

import { PGlite } from '@electric-sql/pglite';
import { electricSync } from '@electric-sql/pglite/sync';
import { live } from '@electric-sql/pglite/live';
import { useEffect, useRef, useState, useCallback } from 'react';
import { z } from 'zod';

// ============================================================================
// SCHEMA
// ============================================================================

const OfflineLeadSchema = z.object({
  id: z.string().uuid(),
  tenant_id: z.string().uuid(),
  name: z.string().min(2),
  email: z.string().email(),
  phone: z.string().optional(),
  message: z.string().min(10),
  synced: z.boolean().default(false),
  created_at: z.string().datetime(),
});

type OfflineLead = z.infer<typeof OfflineLeadSchema>;

// ============================================================================
// PGlite SINGLETON (persisted to IndexedDB)
// ============================================================================

let _pg: PGlite | null = null;

async function getPGlite(tenantId: string): Promise<PGlite> {
  if (_pg) return _pg;

  _pg = await PGlite.create({
    // Persist to IndexedDB keyed by tenantId
    dataDir: `idb://offline-leads-${tenantId}`,
    extensions: {
      electric: electricSync(),
      live,
    },
  });

  // Create local leads table for offline storage
  await _pg.exec(`
    CREATE TABLE IF NOT EXISTS offline_leads (
      id          TEXT PRIMARY KEY DEFAULT gen_random_uuid()::text,
      tenant_id   TEXT NOT NULL,
      name        TEXT NOT NULL,
      email       TEXT NOT NULL,
      phone       TEXT,
      message     TEXT NOT NULL,
      synced      BOOLEAN NOT NULL DEFAULT FALSE,
      created_at  TIMESTAMPTZ NOT NULL DEFAULT now()
    );
  `);

  return _pg;
}

// ============================================================================
// SYNC: Upload unsynced leads to server when online
// ============================================================================

async function syncPendingLeads(pg: PGlite, tenantId: string): Promise<void> {
  const { rows } = await pg.query<OfflineLead>(
    'SELECT * FROM offline_leads WHERE synced = FALSE AND tenant_id = $1',
    [tenantId]
  );

  for (const lead of rows) {
    try {
      const res = await fetch('/api/leads/sync', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(lead),
      });

      if (res.ok) {
        await pg.query(
          'UPDATE offline_leads SET synced = TRUE WHERE id = $1',
          [lead.id]
        );
      }
    } catch {
      // Network failure — will retry on next online event
    }
  }
}

// ============================================================================
// COMPONENT
// ============================================================================

interface OfflineLeadFormProps {
  tenantId: string;
  onSuccess?: (leadId: string) => void;
}

export function OfflineLeadForm({ tenantId, onSuccess }: OfflineLeadFormProps) {
  const pgRef = useRef<PGlite | null>(null);
  const [isOnline, setIsOnline] = useState(
    typeof navigator !== 'undefined' ? navigator.onLine : true
  );
  const [pendingCount, setPendingCount] = useState(0);
  const [submitting, setSubmitting] = useState(false);
  const [submitted, setSubmitted] = useState(false);

  // Initialize PGlite and register online/offline listeners
  useEffect(() => {
    getPGlite(tenantId).then((pg) => {
      pgRef.current = pg;
      // Count pending unsynced leads
      pg.query<{ count: string }>(
        'SELECT COUNT(*) as count FROM offline_leads WHERE synced = FALSE'
      ).then(({ rows }) => setPendingCount(Number(rows[0]?.count ?? 0)));
    });

    const handleOnline = () => {
      setIsOnline(true);
      if (pgRef.current) syncPendingLeads(pgRef.current, tenantId);
    };
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, [tenantId]);

  const handleSubmit = useCallback(
    async (e: React.FormEvent<HTMLFormElement>) => {
      e.preventDefault();
      setSubmitting(true);

      const formData = new FormData(e.currentTarget);
      const payload = {
        id: crypto.randomUUID(),
        tenant_id: tenantId,
        name: formData.get('name') as string,
        email: formData.get('email') as string,
        phone: (formData.get('phone') as string) || undefined,
        message: formData.get('message') as string,
        synced: false,
        created_at: new Date().toISOString(),
      };

      const validation = OfflineLeadSchema.safeParse(payload);
      if (!validation.success) {
        setSubmitting(false);
        return;
      }

      const pg = pgRef.current!;

      // Always write to local PGlite first (works offline)
      await pg.query(
        `INSERT INTO offline_leads (id, tenant_id, name, email, phone, message, created_at)
         VALUES ($1, $2, $3, $4, $5, $6, $7)`,
        [
          payload.id,
          payload.tenant_id,
          payload.name,
          payload.email,
          payload.phone ?? null,
          payload.message,
          payload.created_at,
        ]
      );

      // If online, sync immediately
      if (isOnline) {
        await syncPendingLeads(pg, tenantId);
      } else {
        setPendingCount((c) => c + 1);
      }

      setSubmitting(false);
      setSubmitted(true);
      onSuccess?.(payload.id);
    },
    [tenantId, isOnline, onSuccess]
  );

  if (submitted) {
    return (
      <div role="status" aria-live="polite" className="p-6 bg-green-50 rounded-lg text-center">
        <p className="text-green-800 font-semibold">
          {isOnline
            ? "We've received your message — we'll be in touch shortly!"
            : "Saved locally. We'll send this when you're back online."}
        </p>
      </div>
    );
  }

  return (
    <form onSubmit={handleSubmit} noValidate aria-label="Contact form">
      {!isOnline && (
        <div role="alert" aria-live="assertive" className="mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded text-sm text-yellow-800">
          You appear to be offline. Your form will be saved and sent automatically when you reconnect.
          {pendingCount > 0 && ` (${pendingCount} message${pendingCount > 1 ? 's' : ''} pending sync)`}
        </div>
      )}

      <div className="space-y-4">
        <div>
          <label htmlFor="name" className="block text-sm font-medium text-gray-700">
            Name <span aria-label="required">*</span>
          </label>
          <input
            id="name"
            name="name"
            type="text"
            required
            autoComplete="name"
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:ring-primary focus:border-primary"
            aria-required="true"
          />
        </div>

        <div>
          <label htmlFor="email" className="block text-sm font-medium text-gray-700">
            Email <span aria-label="required">*</span>
          </label>
          <input
            id="email"
            name="email"
            type="email"
            required
            autoComplete="email"
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:ring-primary focus:border-primary"
            aria-required="true"
          />
        </div>

        <div>
          <label htmlFor="phone" className="block text-sm font-medium text-gray-700">Phone</label>
          <input
            id="phone"
            name="phone"
            type="tel"
            autoComplete="tel"
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:ring-primary focus:border-primary"
          />
        </div>

        <div>
          <label htmlFor="message" className="block text-sm font-medium text-gray-700">
            Message <span aria-label="required">*</span>
          </label>
          <textarea
            id="message"
            name="message"
            rows={4}
            required
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:ring-primary focus:border-primary"
            aria-required="true"
          />
        </div>

        <button
          type="submit"
          disabled={submitting}
          className="w-full bg-primary text-white px-6 py-3 rounded-lg font-semibold hover:bg-primary/90 disabled:opacity-50 focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-primary"
          aria-disabled={submitting}
          aria-busy={submitting}
        >
          {submitting ? 'Sending…' : 'Send Message'}
        </button>
      </div>
    </form>
  );
}
```

**Server-side sync endpoint:**

```typescript
// apps/*/src/app/api/leads/sync/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { db } from '@repo/db';
import { z } from 'zod';

const SyncLeadSchema = z.object({
  id: z.string().uuid(),
  tenant_id: z.string().uuid(),
  name: z.string(),
  email: z.string().email(),
  phone: z.string().nullable().optional(),
  message: z.string(),
  created_at: z.string().datetime(),
});

export async function POST(req: NextRequest) {
  const body = await req.json();
  const parsed = SyncLeadSchema.safeParse(body);

  if (!parsed.success) {
    return NextResponse.json({ error: 'Invalid payload' }, { status: 400 });
  }

  const { id, tenant_id, name, email, phone, message, created_at } = parsed.data;

  // Idempotent upsert — safe to call multiple times with same ID
  const { error } = await db.from('leads').upsert(
    {
      id,
      tenant_id,
      name,
      email,
      phone: phone ?? null,
      message,
      source: 'offline_form',
      created_at,
    },
    { onConflict: 'id', ignoreDuplicates: true }
  );

  if (error) {
    console.error('[Lead Sync Error]', error);
    return NextResponse.json({ error: 'Sync failed' }, { status: 500 });
  }

  return NextResponse.json({ ok: true });
}
```

---
