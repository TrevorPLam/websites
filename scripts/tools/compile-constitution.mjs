#!/usr/bin/env node

/**
 * Constitution Compiler
 *
 * Reads .repo/policy/constitution.json and generates Copilot instruction files
 * from the structured JSON data.
 *
 * Generated files:
 * - .github/copilot-instructions.md (Global instructions)
 * - .github/instructions/docs.instructions.md (Documentation instructions)
 * - .github/instructions/client.instructions.md (Client/Frontend instructions)
 * - .github/instructions/server.instructions.md (Server/Backend instructions)
 *
 * Generated files include a header indicating they are auto-generated.
 */

import { readFileSync, writeFileSync, existsSync, mkdirSync } from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const REPO_ROOT = join(__dirname, "../..");
const CONSTITUTION_PATH = join(REPO_ROOT, ".repo/policy/constitution.json");
const OUTPUT_DIR = join(REPO_ROOT, ".github");
const INSTRUCTIONS_DIR = join(OUTPUT_DIR, "instructions");

function generateHeader(targetName) {
  const timestamp = new Date().toISOString().split("T")[0];
  return `<!-- AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY -->
<!-- Source: .repo/policy/constitution.json -->
<!-- Generated: ${timestamp} -->
<!-- To update: edit constitution.json and run \`npm run compile:constitution\` -->

# ${targetName}

**⚠️ This file is AUTO-GENERATED from the constitution.**

**To make changes:**
1. Edit \`.repo/policy/constitution.json\`
2. Run \`npm run compile:constitution\`
3. Commit both files together

**Do NOT edit this file directly** - your changes will be overwritten.

---

`;
}

function generateFooter() {
  return `

---

**Source:** \`.repo/policy/constitution.json\`  
**Compiler:** \`scripts/tools/compile-constitution.mjs\`  
**Last Generated:** ${new Date().toISOString()}
`;
}

function formatArticle(article) {
  let text = `#### ${article.id}. ${article.title}\n`;
  text += `- ${article.rule}\n`;
  if (article.if_needed) {
    text += `- *If needed:* ${article.if_needed}\n`;
  }
  return text;
}

function formatPrinciple(principle) {
  let text = `- **${principle.id}**: ${principle.rule}\n`;
  if (principle.if_needed) {
    text += `  - *If needed:* ${principle.if_needed}\n`;
  }
  return text;
}

function generateGlobalInstructions(constitution) {
  const sections = [];

  // Core Laws (Articles)
  sections.push("### Core Laws\n");
  constitution.constitution.articles.forEach((article) => {
    sections.push(formatArticle(article));
  });

  // Principles
  sections.push("\n### Principles\n");
  constitution.principles.list.forEach((principle) => {
    sections.push(formatPrinciple(principle));
  });

  // Global Rule
  if (constitution.principles.global_rule) {
    sections.push(`\n**Global Rule:** ${constitution.principles.global_rule}\n`);
  }

  // Best Practices - Repository Map
  if (constitution.best_practices?.repository_map) {
    sections.push("\n### Repository Structure\n");
    sections.push("Key directories and their purposes:\n");
    Object.entries(constitution.best_practices.repository_map).forEach(
      ([path, purpose]) => {
        sections.push(`- **\`${path}\`**: ${purpose}\n`);
      },
    );
  }

  // Best Practices - Tech Stack
  if (constitution.best_practices?.tech_stack) {
    sections.push("\n### Technology Stack\n");
    Object.entries(constitution.best_practices.tech_stack).forEach(
      ([area, stack]) => {
        sections.push(`- **${area}**: ${stack}\n`);
      },
    );
  }

  // Best Practices - Coding Patterns
  if (constitution.best_practices?.coding_patterns) {
    sections.push("\n### Coding Patterns\n");
    Object.entries(constitution.best_practices.coding_patterns).forEach(
      ([area, pattern]) => {
        sections.push(`- **${area}**: ${pattern}\n`);
      },
    );
  }

  // Security - Absolute Prohibitions
  if (constitution.security?.absolute_prohibitions) {
    sections.push("\n### Security Requirements\n");
    constitution.security.absolute_prohibitions.forEach((prohibition) => {
      sections.push(`- ${prohibition}\n`);
    });
  }

  // Quality Gates
  if (constitution.quality_gates) {
    sections.push("\n### Quality Gates\n");
    sections.push(
      `**Merge Policy:** ${constitution.quality_gates.merge_policy}\n`,
    );
    if (constitution.quality_gates.hard_gates?.length > 0) {
      sections.push("\n**Hard Gates (Merge Blocking):**\n");
      constitution.quality_gates.hard_gates.forEach((gate) => {
        sections.push(`- ${gate}\n`);
      });
    }
  }

  return sections.join("");
}

function generateDocsInstructions(constitution) {
  const sections = [];

  sections.push("### Documentation Laws\n");

  // Article 2: Verifiable over Persuasive (relevant for docs)
  const article2 = constitution.constitution.articles.find((a) => a.id === 2);
  if (article2) {
    sections.push(formatArticle(article2));
  }

  // Principle 19: Docs Age With Code
  const principle19 = constitution.principles.list.find((p) => p.id === 19);
  if (principle19) {
    sections.push("\n#### Documentation Principles\n");
    sections.push(formatPrinciple(principle19));
  }

  // Principle 16: Decisions Written Down
  const principle16 = constitution.principles.list.find((p) => p.id === 16);
  if (principle16) {
    sections.push(formatPrinciple(principle16));
  }

  // Best Practices - Repository Map (docs section)
  if (constitution.best_practices?.repository_map?.docs) {
    sections.push("\n### Documentation Structure\n");
    sections.push(
      `- **\`docs/\`**: ${constitution.best_practices.repository_map.docs}\n`,
    );
  }

  return sections.join("");
}

function generateClientInstructions(constitution) {
  const sections = [];

  sections.push("### Client/Frontend Laws\n");

  // Best Practices - Tech Stack (mobile)
  if (constitution.best_practices?.tech_stack?.mobile) {
    sections.push("\n#### Technology Stack\n");
    sections.push(
      `- **Mobile**: ${constitution.best_practices.tech_stack.mobile}\n`,
    );
  }

  // Best Practices - Coding Patterns (client)
  if (constitution.best_practices?.coding_patterns?.client) {
    sections.push("\n#### Coding Patterns\n");
    sections.push(
      `- ${constitution.best_practices.coding_patterns.client}\n`,
    );
  }

  // Repository Map (mobile)
  if (constitution.best_practices?.repository_map?.apps) {
    sections.push("\n#### Repository Structure\n");
    sections.push(
      `- **\`apps/mobile\`**: React Native mobile application\n`,
    );
  }

  // Boundaries
  if (constitution.boundaries) {
    sections.push("\n#### Boundary Rules\n");
    sections.push(
      `- **Import Direction**: ${constitution.boundaries.import_direction}\n`,
    );
    sections.push(
      `- **Cross-Feature Rule**: ${constitution.boundaries.cross_feature_rule}\n`,
    );
  }

  return sections.join("");
}

function generateServerInstructions(constitution) {
  const sections = [];

  sections.push("### Server/Backend Laws\n");

  // Best Practices - Tech Stack (backend)
  if (constitution.best_practices?.tech_stack?.backend) {
    sections.push("\n#### Technology Stack\n");
    sections.push(
      `- **Backend**: ${constitution.best_practices.tech_stack.backend}\n`,
    );
  }

  // Best Practices - Coding Patterns (server)
  if (constitution.best_practices?.coding_patterns?.server) {
    sections.push("\n#### Coding Patterns\n");
    sections.push(
      `- ${constitution.best_practices.coding_patterns.server}\n`,
    );
  }

  // Repository Map (api)
  if (constitution.best_practices?.repository_map?.apps) {
    sections.push("\n#### Repository Structure\n");
    sections.push(`- **\`apps/api\`**: Express API server\n`);
  }

  // Security - Input Validation
  sections.push("\n#### Security Requirements\n");
  sections.push(
    "- ALL inputs must be validated with Zod schemas\n",
  );
  sections.push("- Never trust request bodies, params, or query strings\n");
  sections.push("- Return structured errors with validation details\n");

  // Security - Review Triggers
  if (constitution.security?.review_triggers) {
    sections.push("\n#### Security Review Triggers\n");
    sections.push(
      "The following changes require security review (HITL):\n",
    );
    Object.entries(
      constitution.security.review_triggers.meanings,
    ).forEach(([id, meaning]) => {
      sections.push(`- **${id}**: ${meaning}\n`);
    });
  }

  return sections.join("");
}

function generateAgentsHeader(targetName, pathType = "global") {
  const timestamp = new Date().toISOString().split("T")[0];
  const agentsJsonPath = pathType === "global" 
    ? "agents.json" 
    : pathType === "docs"
    ? "../../agents.json"
    : "../../agents.json";
  
  return `<!-- AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY -->
<!-- Source: .repo/policy/constitution.json -->
<!-- Generated: ${timestamp} -->
<!-- To update: edit constitution.json and run \`npm run compile:constitution\` -->

# ${targetName}

**⚠️ This file is AUTO-GENERATED from the constitution.**

**To make changes:**
1. Edit \`.repo/policy/constitution.json\`
2. Run \`npm run compile:constitution\`
3. Commit both files together

**Do NOT edit this file directly** - your changes will be overwritten.

---

<<SEE ${agentsJsonPath}>>

`;
}

function generateGlobalAgents(constitution) {
  const sections = [];

  sections.push("## Agent Entry Point\n");
  sections.push("See `agents.json` for complete agent workflow, command routing, and decision trees.\n");

  sections.push("\n## Key Workflow (from Constitution)\n");
  if (constitution.workflow?.three_pass) {
    sections.push("All changes follow the three-pass workflow:\n");
    sections.push("1. **Pass 0 (Context)**: Read folder context files\n");
    sections.push("2. **Pass 1 (Plan)**: Determine change type, list actions, identify risks\n");
    sections.push("3. **Pass 2 (Change)**: Apply edits following existing patterns\n");
    sections.push("4. **Pass 3 (Verify)**: Run tests, provide evidence, update logs\n");
  }

  sections.push("\n## Required Reading (from Constitution)\n");
  sections.push("Before starting work, read:\n");
  sections.push("- `.repo/tasks/TODO.md`\n");
  sections.push("- `.repo/repo.manifest.yaml`\n");
  sections.push("- `.repo/policy/constitution.json`\n");

  return sections.join("");
}

function generateDocsAgents(constitution) {
  const sections = [];

  sections.push("## Documentation Agent Entry Point\n");
  sections.push("See `../../agents.json` for complete agent workflow.\n");

  sections.push("\n## Documentation-Specific Context\n");
  const principle19 = constitution.principles.list.find((p) => p.id === 19);
  if (principle19) {
    sections.push(`- **Principle ${principle19.id}**: ${principle19.rule}\n`);
  }

  return sections.join("");
}

function generateClientAgents(constitution) {
  const sections = [];

  sections.push("## Client/Frontend Agent Entry Point\n");
  sections.push("See `../../agents.json` for complete agent workflow.\n");

  sections.push("\n## Client-Specific Context\n");
  if (constitution.best_practices?.tech_stack?.mobile) {
    sections.push(`- **Tech Stack**: ${constitution.best_practices.tech_stack.mobile}\n`);
  }
  if (constitution.boundaries?.import_direction) {
    sections.push(`- **Import Direction**: ${constitution.boundaries.import_direction}\n`);
  }

  return sections.join("");
}

function generateServerAgents(constitution) {
  const sections = [];

  sections.push("## Server/Backend Agent Entry Point\n");
  sections.push("See `../../agents.json` for complete agent workflow.\n");

  sections.push("\n## Server-Specific Context\n");
  if (constitution.best_practices?.tech_stack?.backend) {
    sections.push(`- **Tech Stack**: ${constitution.best_practices.tech_stack.backend}\n`);
  }
  if (constitution.security?.review_triggers) {
    sections.push("\n## Security Review Triggers\n");
    sections.push("The following changes require security review (HITL):\n");
    Object.entries(constitution.security.review_triggers.meanings).forEach(
      ([id, meaning]) => {
        sections.push(`- **${id}**: ${meaning}\n`);
      },
    );
  }

  return sections.join("");
}

function compileConstitution() {
  console.log("Constitution Compiler");
  console.log("====================\n");

  // Check if constitution exists
  if (!existsSync(CONSTITUTION_PATH)) {
    console.error(`Error: Constitution not found at: ${CONSTITUTION_PATH}`);
    process.exit(1);
  }

  // Read constitution
  console.log(`Reading constitution from: ${CONSTITUTION_PATH}`);
  const constitutionContent = readFileSync(CONSTITUTION_PATH, "utf-8");
  let constitution;
  try {
    constitution = JSON.parse(constitutionContent);
  } catch (error) {
    console.error(`Error: Invalid JSON in constitution file`);
    console.error(error.message);
    process.exit(1);
  }

  // Ensure output directories exist
  if (!existsSync(OUTPUT_DIR)) {
    mkdirSync(OUTPUT_DIR, { recursive: true });
  }
  if (!existsSync(INSTRUCTIONS_DIR)) {
    mkdirSync(INSTRUCTIONS_DIR, { recursive: true });
  }

  console.log("Generating copilot instruction files...\n");

  // Generate Global Instructions
  const globalContent =
    generateHeader("Global Copilot Instructions") +
    generateGlobalInstructions(constitution) +
    generateFooter();
  const globalPath = join(OUTPUT_DIR, "copilot-instructions.md");
  writeFileSync(globalPath, globalContent, "utf-8");
  console.log(`Generated: ${globalPath}`);

  // Generate Global AGENTS.md
  const globalAgentsContent =
    generateAgentsHeader("Global Agent Instructions", "global") +
    generateGlobalAgents(constitution) +
    generateFooter();
  const globalAgentsPath = join(OUTPUT_DIR, "AGENTS.md");
  writeFileSync(globalAgentsPath, globalAgentsContent, "utf-8");
  console.log(`Generated: ${globalAgentsPath}`);

  // Generate Docs Instructions
  const docsContent =
    generateHeader("Documentation Path Instructions") +
    generateDocsInstructions(constitution) +
    generateFooter();
  const docsPath = join(INSTRUCTIONS_DIR, "docs.instructions.md");
  writeFileSync(docsPath, docsContent, "utf-8");
  console.log(`Generated: ${docsPath}`);

  // Generate Docs AGENTS.md
  const docsAgentsContent =
    generateAgentsHeader("Documentation Agent Instructions", "docs") +
    generateDocsAgents(constitution) +
    generateFooter();
  const docsAgentsPath = join(INSTRUCTIONS_DIR, "docs.AGENTS.md");
  writeFileSync(docsAgentsPath, docsAgentsContent, "utf-8");
  console.log(`Generated: ${docsAgentsPath}`);

  // Generate Client Instructions
  const clientContent =
    generateHeader("Client/Frontend Path Instructions") +
    generateClientInstructions(constitution) +
    generateFooter();
  const clientPath = join(INSTRUCTIONS_DIR, "client.instructions.md");
  writeFileSync(clientPath, clientContent, "utf-8");
  console.log(`Generated: ${clientPath}`);

  // Generate Client AGENTS.md
  const clientAgentsContent =
    generateAgentsHeader("Client/Frontend Agent Instructions", "client") +
    generateClientAgents(constitution) +
    generateFooter();
  const clientAgentsPath = join(INSTRUCTIONS_DIR, "client.AGENTS.md");
  writeFileSync(clientAgentsPath, clientAgentsContent, "utf-8");
  console.log(`Generated: ${clientAgentsPath}`);

  // Generate Server Instructions
  const serverContent =
    generateHeader("Server/Backend Path Instructions") +
    generateServerInstructions(constitution) +
    generateFooter();
  const serverPath = join(INSTRUCTIONS_DIR, "server.instructions.md");
  writeFileSync(serverPath, serverContent, "utf-8");
  console.log(`Generated: ${serverPath}`);

  // Generate Server AGENTS.md
  const serverAgentsContent =
    generateAgentsHeader("Server/Backend Agent Instructions", "server") +
    generateServerAgents(constitution) +
    generateFooter();
  const serverAgentsPath = join(INSTRUCTIONS_DIR, "server.AGENTS.md");
  writeFileSync(serverAgentsPath, serverAgentsContent, "utf-8");
  console.log(`Generated: ${serverAgentsPath}`);

  console.log("\nSummary:");
  console.log("   Generated: 8 files (4 instruction files + 4 AGENTS.md files)");
  console.log("\nConstitution compiled successfully!");
  console.log("\nNext steps:");
  console.log("   1. Review generated files");
  console.log("   2. Commit changes: git add .github/ .repo/policy/");
  console.log("   3. Push to repository");
}

// Run compiler
try {
  compileConstitution();
} catch (error) {
  console.error("\nError compiling constitution:");
  console.error(error.message);
  console.error(error.stack);
  process.exit(1);
}
