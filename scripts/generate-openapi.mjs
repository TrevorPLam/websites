#!/usr/bin/env node
/**
 * Meta-commentary:
 * - Current Status: Generates the committed OpenAPI contract for CI drift checks.
 * - Mapping: Documents the /api/og endpoint exposed by app/api/og/route.tsx.
 * - Reasoning: Keeps schema output deterministic and easy to review for API changes.
 * - Assumption: /api/og is the only public API route today; extend the spec when adding routes.
 */

import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const repoRoot = path.resolve(__dirname, '..')
const openApiPath = path.join(repoRoot, 'docs', 'apis', 'openapi', 'openapi.yaml')

const openApiSpec = {
  openapi: '3.0.3',
  info: {
    title: 'Your Dedicated Marketer API',
    version: '1.0.0',
    description:
      'Public API contract for the marketing site. Update this file whenever API routes change.',
  },
  paths: {
    '/api/og': {
      get: {
        summary: 'Generate an Open Graph image',
        description:
          'Returns a PNG image for social sharing with optional title and description query params.',
        parameters: [
          {
            name: 'title',
            in: 'query',
            required: false,
            description: 'Optional headline for the OG image.',
            schema: {
              type: 'string',
              maxLength: 200,
            },
          },
          {
            name: 'description',
            in: 'query',
            required: false,
            description: 'Optional supporting text for the OG image.',
            schema: {
              type: 'string',
              maxLength: 500,
            },
          },
        ],
        responses: {
          '200': {
            description: 'Open Graph PNG image.',
            content: {
              'image/png': {
                schema: {
                  type: 'string',
                  format: 'binary',
                },
              },
            },
          },
          '400': {
            description: 'Invalid query parameters.',
            content: {
              'text/plain': {
                schema: {
                  type: 'string',
                },
              },
            },
          },
        },
      },
    },
  },
}

const yamlHeader = [
  '# Meta-commentary:',
  '# - Current Status: Generated OpenAPI contract for CI drift detection.',
  '# - Mapping: /api/og => app/api/og/route.tsx GET handler.',
  '# - Reasoning: Keep committed API contract in sync with production behavior.',
  '# - Assumption: Add new routes here before shipping API changes.',
  '#',
  '# This file is generated by scripts/generate-openapi.mjs. Do not edit manually.',
  '',
].join('\n')

const yamlBody = toYaml(openApiSpec).trimEnd() + '\n'

fs.mkdirSync(path.dirname(openApiPath), { recursive: true })
fs.writeFileSync(openApiPath, yamlHeader + yamlBody, 'utf8')

console.log(`âœ… OpenAPI contract written to ${path.relative(repoRoot, openApiPath)}`)

function toYaml(value, indent = 0) {
  if (Array.isArray(value)) {
    return value
      .map(item => `${' '.repeat(indent)}- ${formatYamlValue(item, indent + 2).trimStart()}`)
      .join('\n')
  }

  if (value && typeof value === 'object') {
    return Object.entries(value)
      .map(([key, entry]) => {
        const formatted = formatYamlValue(entry, indent + 2)
        const isComplex = Array.isArray(entry) || (entry && typeof entry === 'object')
        if (isComplex || formatted.includes('\n')) {
          return `${' '.repeat(indent)}${key}:\n${formatted}`
        }
        return `${' '.repeat(indent)}${key}: ${formatted}`
      })
      .join('\n')
  }

  return formatYamlScalar(value)
}

function formatYamlValue(value, indent) {
  if (Array.isArray(value) || (value && typeof value === 'object')) {
    return toYaml(value, indent)
  }

  return formatYamlScalar(value)
}

function formatYamlScalar(value) {
  if (value === null || value === undefined) {
    return 'null'
  }

  if (typeof value === 'number' || typeof value === 'boolean') {
    return String(value)
  }

  const stringValue = String(value)
  if (stringValue === '' || /[:#\n\r\t]|^\s|\s$/.test(stringValue)) {
    return JSON.stringify(stringValue)
  }

  return stringValue
}
