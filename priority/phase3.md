```json
{
  "phase_id": "PHASE-3",
  "phase_name": "Manifest (Fillable) + Command Resolution Standard",
  "files": [
    {
      "path": "/.repo/repo.manifest.yaml",
      "type": "yaml",
      "content": "# /.repo/repo.manifest.yaml\n# SOURCE OF TRUTH for executable commands + verification profiles.\n# RULE: Agents MUST NOT guess commands. If unknown, set <UNKNOWN> and open HITL.\n\nrepo:\n  ships: true\n  ship_kind: user_facing_app\n  release_protects: [app_stability, login_security, money_flows]\n\nprerequisites:\n  package_manager: npm\n  runtime_pinned: true\n  platform_tools_required_for_release: true\n\n# Canonical commands (names are fixed). Fill values by following /.repo/docs/standards/manifest.md\n# Placeholders:\n# - <UNKNOWN> = cannot determine from repo contents. Must create HITL item and stop on that portion.\n# - <FILL_FROM_REPO> = deterministically discoverable from repo; fill before merge (or waiver if allowed).\ncommands:\n  install: \"<FILL_FROM_REPO>\"\n  check:quick: \"<FILL_FROM_REPO>\"        # MUST include a fast build for the app\n  check:ci: \"<FILL_FROM_REPO>\"           # quick + required tests + full build\n  check:release: \"<FILL_FROM_REPO>\"      # ci + security + budgets\n  check:governance: \"<FILL_FROM_REPO>\"   # governance-verify (repo local or via node script)\n  check:boundaries: \"<FILL_FROM_REPO>\"   # boundary checker (hybrid)\n  check:security: \"<FILL_FROM_REPO>\"     # dep scan + secrets scan + forbidden patterns\n\nverify_profiles:\n  quick: [check:quick]\n  ci: [check:ci]\n  release: [check:release]\n  governance: [check:governance]\n\ntests:\n  required_level: unit+integration\n\nbudgets:\n  mode: both               # bundle + runtime\n  enforcement: hard_fail_with_waiver\n  fallback_to_default: true\n  # defaults live in: /.repo/policy/QUALITY_GATES.md (if repo-specific budgets missing)\n\nsecurity:\n  every_pr: true\n  release_includes_security: true\n  dependency_vulns_always_hitl: true\n  secrets_absolute_prohibition: true\n  forbidden_patterns_source: \"/.repo/policy/SECURITY_BASELINE.md\"\n\nboundaries:\n  enforcement: hybrid_checker_plus_manifest_edges\n  edges_model: layered_allow_list\n  # Explicit edges represent allowed exceptions beyond the default import direction.\n  # Format: from -> to, with reason + required ADR if cross-feature.\n  edges: []\n"
    },
    {
      "path": "/.repo/docs/standards/manifest.md",
      "type": "markdown",
      "content": "# /.repo/docs/standards/manifest.md\nThis file explains, in plain English, how to fill `/.repo/repo.manifest.yaml` **without guessing**.\n\n## What the manifest is\nThe manifest is the repo’s **instruction card** for running checks. Agents must run commands exactly as written here.\n\n## Non-negotiable rule\nIf you cannot prove the correct command from the repo itself, set the value to `<UNKNOWN>`, create a HITL item, and stop on that portion.\n\n## Command Resolution Process (do this in order)\nFor each command in `commands:` (install, check:quick, check:ci, check:release, check:governance, check:boundaries, check:security):\n\n1) Look for `package.json` scripts that already do the job.\n   - Prefer scripts named like: install/setup, lint, typecheck, test, build, verify, security, audit.\n2) Look for a Makefile, Taskfile, or `scripts/` folder command wrappers.\n3) Look at existing CI config (GitHub Actions, etc.) to see what it runs.\n4) Look at README or /docs instructions.\n5) If more than one candidate exists:\n   - Choose the one used in CI (most authoritative).\n   - If CI is inconsistent or unclear → `<UNKNOWN>` + HITL.\n\n## What each command must accomplish (plain English)\n- `install`: installs dependencies and any required setup steps to run checks.\n- `check:quick`: fast sanity check **plus a fast build** of the app.\n- `check:ci`: full correctness check = quick + required tests + full build.\n- `check:security`: runs dependency scan + secrets scan + forbidden pattern scan.\n- `check:release`: ci + security + budgets (bundle/perf). This protects users, login/security, and money flows.\n- `check:boundaries`: runs boundary enforcement (hybrid checker) and fails on violations unless ADR/waiver rules apply.\n- `check:governance`: runs governance verification (structure + required artifacts + logs/trace schema + HITL/waivers).\n\n## Placeholders\n- `<FILL_FROM_REPO>`: you must replace it before merging governance adoption PR.\n- `<UNKNOWN>`: allowed only when the repo does not contain enough information. Must open HITL and stop.\n\n## What blocks merge\n- Any PR that claims compliance but leaves required commands as `<UNKNOWN>` without a completed HITL item (or a valid waiver, if policy allows).\n- Any command that is present but does not do what the manifest promises.\n\n## Minimal acceptance check after filling the manifest\n- Running the manifest commands locally (or in CI) succeeds for quick/ci/governance.\n- release succeeds or fails with a clear waiverable reason (budgets) or HITL reason (security vulnerabilities).\n"
    }
  ],
  "acceptance_criteria": [
    "Manifest exists and includes canonical command names and verify_profiles.",
    "manifest.md provides a deterministic command resolution process and UNKNOWN handling."
  ],
  "handoff_notes": [
    "Agents must not guess; use manifest.md resolution steps.",
    "If multiple commands exist or CI is unclear: set <UNKNOWN>, create HITL item, stop on that portion."
  ]
}
```