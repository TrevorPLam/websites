/**
 * Security Vulnerability Tests
 * Validates that all critical security issues have been properly fixed
 */

import { registerSAMLProvider } from '@repo/auth';
import { useFeatureFlag } from '@repo/feature-flags';
import { JobScheduler } from '@repo/jobs';
import { scoreLead } from '@repo/lead-capture';
import { renderHook } from '@testing-library/react';
import { beforeEach, describe, expect, it, vi } from 'vitest';

// Mock external dependencies
vi.mock('@upstash/redis', () => ({
  Redis: {
    fromEnv: () => ({
      get: vi.fn(),
      set: vi.fn(),
      del: vi.fn(),
      hgetall: vi.fn(),
    }),
  },
}));

vi.mock('@vercel/edge-config', () => ({
  get: vi.fn(),
}));

vi.mock('@supabase/supabase-js', () => ({
  createClient: vi.fn(),
}));

describe('Security Vulnerability Fixes', () => {
  beforeEach(() => {
    // Reset all mocks
    vi.clearAllMocks();

    // Mock document.cookie for feature flag tests
    Object.defineProperty(document, 'cookie', {
      writable: true,
      value: 'ff_offline_lead_forms=true; ff_realtime_lead_feed=false; ff_test_with=value=equals',
    });
  });

  describe('Feature Flags Security', () => {
    it('should parse cookies correctly with equals signs in values', () => {
      const { result } = renderHook(() => useFeatureFlag('offline_lead_forms'));
      expect(result.current).toBe(true);
    });

    it('should handle cookies with complex values', () => {
      // This should not crash when parsing cookies with = in values
      const { result } = renderHook(() => useFeatureFlag('test_with'));
      expect(result.current).toBe(false); // Should return false, not undefined
    });

    it('should validate feature flags using const tuple', () => {
      // Test that the new validation function works
      const { isValidFeatureFlag } = require('@repo/feature-flags');
      expect(isValidFeatureFlag('offline_lead_forms')).toBe(true);
      expect(isValidFeatureFlag('invalid_flag')).toBe(false);
    });

    it('should set feature flag overrides with TTL', async () => {
      const mockRedis = require('@upstash/redis').Redis.fromEnv();
      mockRedis.set.mockResolvedValue('OK');

      const { setTenantFeatureOverride } = require('@repo/feature-flags');
      await setTenantFeatureOverride('tenant-123', 'offline_lead_forms', true);

      expect(mockRedis.set).toHaveBeenCalledWith(
        'feature:tenant-123:offline_lead_forms',
        true,
        { ex: 90 * 24 * 60 * 60 } // 90 days TTL
      );
    });
  });

  describe('Lead Scoring Security', () => {
    it('should use tenant-scoped session keys', async () => {
      const mockRedis = require('@upstash/redis').Redis.fromEnv();
      mockRedis.hgetall.mockResolvedValue({
        pageViews: '3',
        durationSeconds: '180',
        hasPhoneClick: 'true',
        hasBookingClick: 'false',
        hasLiveChat: 'false',
        isRepeatVisitor: 'false',
      });

      const score = await scoreLead({
        tenantId: 'tenant-123',
        sessionId: 'session-456',
        attribution: { firstTouch: null, lastTouch: null },
        hasPhone: true,
        messageLength: 100,
        submittedAt: new Date('2026-02-24T10:00:00Z'),
      });

      expect(mockRedis.hgetall).toHaveBeenCalledWith('session:tenant-123:session-456');
      expect(score).toBeGreaterThan(0);
    });

    it('should prevent cross-tenant session access', async () => {
      const mockRedis = require('@upstash/redis').Redis.fromEnv();
      mockRedis.hgetall.mockResolvedValue(null);

      const score = await scoreLead({
        tenantId: 'tenant-123',
        sessionId: 'session-456',
        attribution: { firstTouch: null, lastTouch: null },
        hasPhone: false,
        messageLength: 50,
      });

      // Should use tenant-scoped key, not global session key
      expect(mockRedis.hgetall).toHaveBeenCalledWith('session:tenant-123:session-456');
      expect(score).toBeLessThan(70); // Should be a low score without session data
    });

    it('should use actual submission timestamp', async () => {
      const mockRedis = require('@upstash/redis').Redis.fromEnv();
      mockRedis.hgetall.mockResolvedValue({
        pageViews: '1',
        durationSeconds: '0',
        hasPhoneClick: 'false',
        hasBookingClick: 'false',
        hasLiveChat: 'false',
        isRepeatVisitor: 'false',
      });

      const submissionTime = new Date('2026-02-24T22:00:00Z'); // Outside business hours
      const score = await scoreLead({
        tenantId: 'tenant-123',
        sessionId: 'session-456',
        attribution: { firstTouch: null, lastTouch: null },
        hasPhone: false,
        messageLength: 50,
        submittedAt: submissionTime,
      });

      // Should not get business hours bonus (22:00 is outside 8-18)
      expect(score).toBeLessThan(70);
    });
  });

  describe('Job Scheduler Security', () => {
    it('should return actual job ID, not hardcoded string', async () => {
      const mockQStash = {
        publishJSON: vi.fn(),
      };

      const scheduler = new JobScheduler({
        tenantId: 'tenant-123',
        qstashToken: 'test-token',
        qstashUrl: 'https://qstash.upstash.io',
      });

      // Mock the qstash client
      scheduler.qstash = mockQStash;

      const jobId = await scheduler.scheduleEmailJob({
        to: ['test@example.com'],
        subject: 'Test Email',
      });

      expect(jobId).toMatch(/^job_tenant-123_[0-9a-f-]+$/); // UUID pattern
      expect(jobId).not.toBe('scheduled');
    });

    it('should use private APP_URL instead of NEXT_PUBLIC_', async () => {
      const originalAppUrl = process.env.APP_URL;
      const originalPublicUrl = process.env.NEXT_PUBLIC_APP_URL;

      process.env.APP_URL = 'https://private.example.com';
      process.env.NEXT_PUBLIC_APP_URL = 'https://public.example.com';

      const mockQStash = {
        publishJSON: vi.fn(),
      };

      const scheduler = new JobScheduler({
        tenantId: 'tenant-123',
        qstashToken: 'test-token',
        qstashUrl: 'https://qstash.upstash.io',
      });

      scheduler.qstash = mockQStash;

      await scheduler.scheduleEmailJob({
        to: ['test@example.com'],
        subject: 'Test Email',
      });

      expect(mockQStash.publishJSON).toHaveBeenCalledWith(
        expect.objectContaining({
          url: 'https://private.example.com/api/jobs/handle',
        })
      );

      // Restore environment variables
      process.env.APP_URL = originalAppUrl;
      process.env.NEXT_PUBLIC_APP_URL = originalPublicUrl;
    });

    it('should use cryptographically secure job IDs', async () => {
      const mockQStash = {
        publishJSON: vi.fn(),
      };

      const scheduler = new JobScheduler({
        tenantId: 'tenant-123',
        qstashToken: 'test-token',
        qstashUrl: 'https://qstash.upstash.io',
      });

      scheduler.qstash = mockQStash;

      const jobId1 = await scheduler.scheduleEmailJob({
        to: ['test@example.com'],
        subject: 'Test Email 1',
      });

      const jobId2 = await scheduler.scheduleEmailJob({
        to: ['test@example.com'],
        subject: 'Test Email 2',
      });

      // Should generate unique UUIDs, not predictable patterns
      expect(jobId1).not.toBe(jobId2);
      expect(jobId1).toMatch(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/);
    });

    it('should throw errors for unimplemented handlers', async () => {
      const { JobHandlerFactory } = require('@repo/jobs');

      const emailHandler = JobHandlerFactory.createHandler('email');

      await expect(
        emailHandler({
          to: ['test@example.com'],
          subject: 'Test',
        })
      ).rejects.toThrow('Email handler not implemented');
    });
  });

  describe('Enterprise SSO Security', () => {
    it('should validate metadata URLs against SSRF', async () => {
      const mockDb = {
        from: vi.fn(() => ({
          select: vi.fn(() => ({
            neq: vi.fn(() => ({
              data: [],
            })),
          })),
          upsert: vi.fn(() => ({ error: null })),
        })),
      };

      // Mock fetch for Supabase API
      global.fetch = vi.fn();

      await expect(
        registerSAMLProvider('tenant-123', {
          metadataUrl: 'http://169.254.169.254/latest/meta-data/', // Internal IP
          domains: ['example.com'],
        })
      ).rejects.toThrow('Metadata URL cannot point to internal addresses');

      await expect(
        registerSAMLProvider('tenant-123', {
          metadataUrl: 'http://evil.com/metadata', // Non-HTTPS
          domains: ['example.com'],
        })
      ).rejects.toThrow('Metadata URL must use HTTPS');
    });

    it('should check for domain uniqueness', async () => {
      const mockDb = {
        from: vi.fn(() => ({
          select: vi.fn(() => ({
            neq: vi.fn(() => ({
              data: [{ domains: ['example.com'] }], // Existing domain
            })),
          })),
          upsert: vi.fn(() => ({ error: null })),
        })),
      };

      global.fetch = vi.fn(() => ({
        ok: true,
        json: () => Promise.resolve({ id: 'provider-123' }),
      }));

      await expect(
        registerSAMLProvider('tenant-456', {
          metadataUrl: 'https://okta.com/metadata',
          domains: ['example.com'], // Already registered by another tenant
        })
      ).rejects.toThrow('Domains already registered by another provider: example.com');
    });

    it('should rollback on database failure', async () => {
      const mockDb = {
        from: vi.fn(() => ({
          select: vi.fn(() => ({
            neq: vi.fn(() => ({
              data: [],
            })),
          })),
          upsert: vi.fn(() => Promise.reject(new Error('Database error'))),
        })),
      };

      let callCount = 0;
      global.fetch = vi.fn(() => {
        callCount++;
        if (callCount === 1) {
          // First call: register provider
          return Promise.resolve({
            ok: true,
            json: () => Promise.resolve({ id: 'provider-123' }),
          });
        } else {
          // Second call: rollback
          return Promise.resolve({
            ok: true,
          });
        }
      });

      await expect(
        registerSAMLProvider('tenant-123', {
          metadataUrl: 'https://okta.com/metadata',
          domains: ['example.com'],
        })
      ).rejects.toThrow('Database write failed, SAML provider rolled back');

      // Should have called fetch twice (register + rollback)
      expect(global.fetch).toHaveBeenCalledTimes(2);
    });
  });

  describe('QStash Webhook Security', () => {
    it('should verify signatures correctly', async () => {
      // This would be tested in the actual webhook handler
      // For now, we test the signature verification logic

      const { verifyQStashSignature } = require('../apps/portal/src/app/api/jobs/handle/route');

      const body = '{"jobId":"test-123","type":"email"}';
      const signingKey = 'test-key';

      // Create valid signature
      const crypto = require('crypto');
      const validSignature = crypto.createHmac('sha256', signingKey).update(body).digest('hex');

      expect(verifyQStashSignature(body, `sha256=${validSignature}`, signingKey)).toBe(true);
      expect(verifyQStashSignature(body, 'invalid-signature', signingKey)).toBe(false);
    });
  });
});
